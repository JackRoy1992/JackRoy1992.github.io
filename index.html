<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:index</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<p><strong>前端知识</strong></p>
<p>注：标题带*为理论，带#为曾经遇到过 BUG</p>
<h1 id="html">HTML</h1>
<h2 id="1-table-">1. 表格 table 属性</h2>
<p><strong>行内样式：</strong></p>
<pre><code class="lang-html">&lt;table
  border=&quot;1&quot;
  cellspacing=&quot;0&quot;
  cellpadding=&quot;0&quot;
  width=&quot;200&quot;
  height=&quot;300&quot;
&gt;&lt;/table&gt;
// cellspacing:设置单元格与单元格边框之间的空白间隙 //
cellpadding:设置单元格内容与边框之间的空白间隙
</code></pre>
<p><strong>CSS 样式：</strong></p>
<pre><code class="lang-css">table {
  width: 200px;
  height: 300px;
  border: 1px solid #000;
  border-collapse: collapse;
  // border-collapse:将边框合并成单一的边框，效果等同于cellspacing
  border-spacing: 0;
  // border-spacing:可以修改单元格与单元格边框之间的空白间隙，但是如果border-collapse: collapse，是没有效果的
}
th,
td {
  border: 1px solid #000;
  padding: 0;
  // padding:0 就是将cellpadding去掉
}
</code></pre>
<p><strong>合并单元格：</strong></p>
<p>合并单元格遵循一个顺序：从上至下，从左往右</p>
<p><code>rowspan</code>跨行合并 <code>colspan</code>跨列合并，都是行内样式，参数为合并单元格的数量</p>
<h2 id="2-">2. 双伪元素清除浮动</h2>
<pre><code class="lang-css">.clearfix::before,
.clearfix::after {
  content: &quot;&quot;;
  display: table;
}
.clearfix::after {
  clear: both;
}
/* 兼容 IE 6 7*/
.clearfix {
  *zoom: 1;
}
</code></pre>
<h2 id="3-">3. 溢出文字</h2>
<ol>
<li>盒子需要<code>overflow:hidden</code>隐藏超出部分；</li>
<li><code>white-space</code>：换行还是一行显示，normal 默认，nowrap 不换行</li>
<li><code>text-overflow</code>：文字溢出，clip 不显示省略号，ellipsis 显示省略号</li>
</ol>
<pre><code class="lang-css">/*单行溢出*/
.one-txt-cut {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
/*多行溢出*/
.txt-cut {
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}
</code></pre>
<h2 id="4-css-">4. CSS 画三角形</h2>
<p>设置一个盒子，宽高为 0，某个边框设置样式，border 的宽度为三角形的高，其他三个边框，设置成透明色</p>
<h2 id="5-">5. 文字阴影</h2>
<p><code>text-shadow</code>：水平偏移 垂直偏移 模糊度 阴影颜色</p>
<p>可以给一个文字设置多个阴影效果，中间使用逗号连接</p>
<h2 id="6-">6. 盒子阴影</h2>
<p><code>box-shadow</code>：水平阴影 垂直阴影 模糊距离（阴影尺寸） 阴影颜色（内/外阴影）</p>
<p>前面两个属性必须写。默认阴影为外部阴影，想设成内部阴影，设置 inset 属性</p>
<h2 id="7-">7. 响应式布局</h2>
<p>根据媒体查询来适配各种屏幕的设备@media(条件)and(条件)...{}</p>
<pre><code class="lang-less">// 定义函数
.adapter(@minWidth) {
  @media (min-width: @minWidth) {
    html {
      font-size: round(@minWidth / 15, 2);
    }
  }
}
.adapter(320px);
.adapter(360px);
.adapter(375px);
.adapter(384px);
.adapter(400px);
.adapter(414px);
.adapter(424px);
.adapter(480px);
.adapter(540px);
.adapter(720px);
.adapter(750px);
// 函数执行时
@media (min-width: 750px) {
  html {
    font-size: 750/50px;
  }
}
</code></pre>
<h2 id="8-rem-">8. rem 布局</h2>
<p>rem 布局将 px 像素换成 rem 单位，由 html 的 font-size 去改变 rem 的大小，<code>px = font-size * rem</code></p>
<pre><code class="lang-js">// jquery
$(function () {
  $(window)
    .resize(function () {
      let width = $(window).width();
      width = Math.max(width, 320); // 设置最小宽度
      width = Math.min(width, 750); // 设置最大宽度
      let fontSize = width / 15;
      $(&quot;html&quot;).css(&quot;fontSize&quot;, fontSize.toFixed(2) + &quot;px&quot;);
    })
    .resize();
});
</code></pre>
<h2 id="9-css-">9. CSS 实现区域滚动</h2>
<ol>
<li>左右分栏区域滚动</li>
</ol>
<p>容器：<code>position:absolute</code> 不给高度，但利用 top 与 bottom 实现高度，使用<code>display:flex</code>布局</p>
<p>内容：一侧给死宽度，另一侧<code>flex:1</code>。都给<code>overflow-y:scroll</code></p>
<ol start="2">
<li>横向区域滚动</li>
</ol>
<p>容器：</p>
<pre><code class="lang-css">.box {
  overflow: auto;
  overflow-x: auto !important;
  overflow-y: hidden;
  white-space: nowrap;
}
</code></pre>
<p>内容：千万不要使用浮动</p>
<pre><code class="lang-css">.content {
  display: inline-block;
}
</code></pre>
<p>以上方法不想使用，就动态渲染容器的宽度</p>
<h2 id="10-">10. 新电脑开发准备</h2>
<ol>
<li><p>下载 node git vsCode</p>
</li>
<li><p>安装 vsCode 插件</p>
<p>Chinese(Simplified)Language：汉化</p>
<p>Auto Rename Tag：修改标签，自动匹配标签闭合</p>
<p>Bracket Pair Colorizer：括号颜色</p>
<p>Easy Less：less 功能</p>
<p>需要配置：设置，右上角打开配置</p>
<pre><code class="lang-json">&quot;less.compile&quot;: {
    &quot;out&quot;: &quot;../css/&quot; //less转化成css文件存放位置
}
</code></pre>
<p>Material Icon Theme：左侧文件图标美化</p>
<p>Open in Browser：设置默认打开文件的浏览器</p>
<p>px2rem：设置 rem</p>
<p>需要配置：设置搜索 rem，修改 font-size</p>
<p>Path Intellisense：智能匹配文件路径</p>
<p>Vetur：vue 支持</p>
</li>
<li><p>react 项目希望 JSX 中，通过 tab 自动生成标签</p>
<p>需要配置：设置，右上角打开配置</p>
<pre><code class="lang-javascript">&quot;emmet.includeLanguages&quot;:{
    &quot;vue-html&quot;:&quot;html&quot;,
    &quot;javascript&quot;:&quot;javascriptreact&quot;,
    &quot;postcss&quot;:&quot;css&quot;
},
&quot;emmet.triggerExpansionOnTab&quot;: true,
&quot;emmet.showSuggestionsAsSnippets&quot;: true,
</code></pre>
</li>
</ol>
<h1 id="javascript-">JavaScript（原生方法）</h1>
<h2 id="1-">1. 修改类名</h2>
<ol>
<li><p>className：仅仅只是获取与修改类名</p>
</li>
<li><p>classList：对类名进行操作</p>
<pre><code class="lang-javascript">classList.add(类名); // 添加类名
classList.remove(类名); // 移除类名
classList.contains(类名); // 判断是否包含类名
classList.toggle(); // 切换类名
</code></pre>
</li>
</ol>
<h2 id="2-">2. 节点查找</h2>
<p><strong>子节点：</strong></p>
<p><code >childNodes</code>：获取所有的子节点（包括元素节点和其他很多类型的节点，基本不用）</p>
<p><code >children</code>：获取所有的子元素，兼容性：IE678 会把注释节点算上
<p><code >firstChild</code>：第一个子节点
<p><code >firstElementChild</code>：第一个子元素，有兼容性问题 IE678
<p><code >lastChild</code>：最后一个节点
<p><code >lastElementChild</code>：最后一个子元素，有兼容性问题 IE678
<p><strong>兄弟节点：</strong></p>
<p><code >nextSibling</code>：下一个兄弟节点
<p><code >nextElementSibling</code>：下一个兄弟元素，有兼容性问题 IE678
<p><code >previousSibling</code>：上一个兄弟节点
<p><code >previousElementSibling</code>：上一个兄弟元素，有兼容性问题 IE678
<p><strong>父节点：</strong></p>
<p><code >parentNode</code>
<h2 id="3-">3. 节点操作</h2>
<p><strong>添加节点：</strong></p>
<p><code>parent.appendChild(child)</code>：在父节点后面添加 child</p>
<p><code>parent.insertBefore(newChild,refChild)</code>：通过父元素在<code>refChild</code>前面添加<code>newChild</code>。如果<code>refChild</code>为<code>null</code>，则在<strong>最后面</strong>添加，如果<code>refChild</code>为<code>parent.firstElementChild</code>，则在<strong>最前面</strong>添加"</p>
<p><strong>创建节点：</strong></p>
<p><code>document.write()</code>：基本不使用，会覆盖原有的页面</p>
<p><code>innerHTML</code>：会覆盖原有的页面</p>
<p><code>document.createElement(标签)</code>：在内存中创建需要的标签，然后往标签内添加内容，再使用添加节点的方法，把创建的标签添加到父元素中</p>
<p><strong>删除节点：</strong></p>
<p><code>parent.removeChild(child)</code>：从父元素中删除 child</p>
<p><strong>替换节点：</strong></p>
<p><code>parent.replaceChild(newChild,oldChild)</code>：用<code>newChild</code>替换<code>oldChild</code></p>
<p><strong>克隆节点：</strong></p>
<p><code>node.cloneNode()</code>：在内存中克隆一个节点。参数为布尔值，<code>true</code>：深克隆，会把标签包括其内容原样克隆，<code>false</code>：浅克隆，只是克隆一个标签"></p>
<h2 id="4-">4. 事件注册</h2>
<p><code>addEventListener(事件类型，事件处理函数，事件是否冒泡)</code>：第三个参数指定事件是否在捕获阶段执行，默认<code>false</code>表示冒泡，<code>true</code>为捕获，优点是可以注册多个事件，不会覆盖</p>
<p><code>removeEventListener(事件类型，注册事件的函数名)</code>：移除绑定事件</p>
<h2 id="5-" >5. 记录鼠标位置</h2>  
<p> <code>e.screenX</code> ，<code>e.screenY</code> ：相对于屏幕左上角</p>
<p><code>e.clientX</code>，<code>e.clientY</code>：相对于可视区</p>
<p><code>e.pageX</code>，<code>e.pageY</code>：相对于 document 页面的左上角（推荐使用）</p>
<h2 id="6-">6. offset 系列</h2> 
<p><code>offsetHeight</code>，<code>offsetWidth</code>：获取元素真实的宽高，只读属性，包含<code>width</code>，<code>padding</code>，<code>border</code></p>
<p><code>offsetLeft</code>，<code>offsetTop</code>：获取盒子距离最近有定位的父元素的真实距离，只读属性，包含<code>margin</code></p>
<p><code>offsetParent</code>：找到离盒子最近的有定位的父元素</p>
<p><img src="./toc/image/offset.png" alt=""></p>
<h2 id='7-'>7. scroll 系列</h2>
<p><code>scrollWidth</code>，<code>scrollHeight</code>：盒子内容的真实的宽度和高度，与盒子大小无关，仅仅与盒子内容有关</p>
<p><code>scrollLeft</code>，<code>scrollTop</code>：获取滚动条的距离</p>
<p><code>onScroll</code>：滚动事件，可以通过注册该事件，用<code>window.pageYOffset</code>获取垂直滚动条滚动距离</p>
<p><img src="./toc/image/scroll.png" alt=""></p>
<h2 id='8-'>8. client 系列</h2>
<p><code>clientWidth</code>，<code>clientHeight</code>：获取内容和 padding 的大小（不包含 border）</p>
<p><code>clientLeft</code>，<code>clientTop</code>：完全没用</p>
<p><img src="./toc/image/client1.png" alt=""></p>
<h2 id='9-'>9. onload 入口函数</h2> 
<p>作用：等待页面加载完成，还会等待图片加载完成</p>
<ol>
  <li><p>如果想要在结构之前获取 DOM 元素</p></li>
  <li><p>如果想要获取图片的宽高</p></li>
 
</ol>
<pre><code class='lang-javascript'>window.onload = function () {
  // 代码会在窗体加载完成后执行
  // 窗体加载完成包括DOM树的加载，图片、文件的加载完成
};
</code></pre>
<p>一个页面如果有两个 onload，后者会覆盖前者</p>
<h2 id="10-location-history-">10. location 和 history 对象</h2>
<p><code>location.href</code>：页面跳转"</p>
<p><code>location.reload()</code>：页面刷新</p>
<p><code>location.search</code>：获取地址栏带的参数？之后的内容</p>
<p><code>location.hash</code>：获取地址栏的 hash 值#之后的内容</p>
<p><code>history.go()</code>：参数 1：下一页，参数 0：当前页，参数-1：上一页</p>
<p><code>history.forward()</code>：前进</p>
<p><code>history.back()</code>：后退</p>

<h2 id='11-'>11. 继承</h2>
<p><strong>1. 混入式继承：</strong>给对象上添加一个 extend 方法，可以遍历其他对象自身的方法，拷贝到自己身上</p>
<pre><code class="lang-javascript">extend:function(obj){
    for(let k in obj){
        // 判断是不是obj自身的属性
        if(obj.hasOwnProperty(k)){
            this[k] = obj[k]
        }
    }
}</code></pre>
<p><strong>2.原型式继承：</strong></p>
<ol>
<li><p>在原型上加属性<code>Person.prototype =</code></p>
</li>
<li><p>原型替换，把构造函数的原型替换成一个新的对象，此方法新对象里需要有<code>constructor</code></p>
<p><code>Person.prototype = {constructor:Person}</code></p>
</li>
<li><p>混入式继承+原型式继承：将混入式的 extend 放在原型上</p>
<pre><code class="lang-javascript">Person.prototype.extend = function (obj) {
  for (let k in obj) {
    // 判断是不是obj自身的属性
    if (obj.hasOwnProperty(k)) {
      this[k] = obj[k];
    }
  }
};
</code></pre>
</li>
</ol>
<p><strong>3.经典继承：</strong></p>
<p><code>var obj = Object.create(proto)</code>：快速让一个对象继承另一个对象，返回值为 obj 新对象，新对象的原型就是 proto</p>
<h2 id="12-call-apply-bind">12. call apply 和 bind</h2>
<pre><code class="lang-javascript">// call直接调用
fn.call(this,参数1，参数2)
// apply直接调用
fn.apply(this,[参数1，参数2])
// bind绑定方法，不会立即执行，this执行第一个参数
let newFn = fn.bind(window)
newFn()
</code></pre>
<h2 id="13-cookie-">13. cookie 设置与删除</h2>
<ol>
<li><p>设置：服务端是通过<code>setCookie</code>的响应头来设置<code>cookie</code>的 。前端通过 <code>document.cookie</code>获取<code>cookies</code></p>
</li>
<li><p>删除：设置<code>max-age = -1</code></p>
<pre><code class="lang-javascript">document.cookies = &quot;a=3;max-age=-1&quot;;
</code></pre>
</li>
</ol>
<h2 id="14-">14. 实现深拷贝</h2>
<p>实现效果</p>
<pre><code class="lang-javascript">const obj = { a: 2, b: [&quot;1&quot;, &quot;2&quot;] };
const objCopy = deepCopy(obj);
obj.a = 1;
console.log(&quot;obj&quot;, obj); //{a:1,b:[&#39;1&#39;,&#39;2&#39;]}
console.log(&quot;objCopy&quot;, objCopy); //{a:2,b:[&#39;1&#39;,&#39;2&#39;]}
</code></pre>
<pre><code class="lang-javascript">function deepCopy(val) {
  // 如果val不是object 或者array 返回
  if (!isObject(val)) return;
  let target = Array.isArray(val) ? [] : {};
  for (const key in val) {
    if (val.hasOwnProperty(key)) {
      if (typeof val[key] === &quot;object&quot;) {
        target[key] = deepCopy(val[key]);
      } else {
        target[key] = val[key];
      }
    }
  }
  return target;
}
function isObject(val) {
  return typeof val === &quot;object&quot; &amp;&amp; val !== null;
}
</code></pre>
<h2 id="-15-event-loop-">*15. Event Loop 与堆栈</h2>
<p>Event Loop：</p>
<p>JavaScript 是单线程的，任务分为同步与异步任务。同步任务会先放到栈里面执行，当同步任务执行完，再开始执行异步任务。异步任务又分为宏任务与微任务，微任务放入微任务序列，宏任务放入宏任务序列。主线程任务执行完成后，会去微任务序列查看是否有任务，有的话，会根据先入先出的顺序将先放进来的微任务放入调用栈中执行，并将任务从微任务序列中移除，执行完后，继续查看微任务序列中是否还有任务，有就执行，没有就查看宏任务序列。宏任务也是根据先入先出的顺序，将先放进去的宏任务放入调用栈中执行，并将该任务从宏任务中移除。执行完后，会去查看微任务序列中是否有任务，有的话就执行微任务。没有的话就查看宏任务序列。</p>
<p>要点：每次宏任务执行完都会去检查微任务序列。</p>
<p>堆栈：</p>
<p>栈是存储基础数据类型的变量以及对象变量的指针，释放的时候是先进后出</p>
<p>堆主要负责类似对象这种变量类型的存储</p>
<h1 id="jquery">JQuery</h1>
<h2 id="1-">1. 筛选选择器</h2>
<p><code>$(&#39;a&#39;).children(&#39;b&#39;)</code>：找到 a 元素中所有子元素中的 b 元素</p>
<p><code>$(&#39;a&#39;).find(&#39;b&#39;)</code>：找到 a 元素所有后代元素中的 b 元素</p>
<p><code>siblings()</code>：所有的兄弟元素"</p>
<p><code>next()</code>：下一个兄弟元素，<code>prev()</code>：上一个兄弟元素，<code>parent()</code>：父元素，<code>eq(index)</code>：找下标的元素</p>
<h2 id='2-'>2. 操作 prop 方法</h2>
<p><code>prop()</code>：<code>checked</code>、<code>selected</code>、<code>disabled</code>这类布尔值的属性，无法使用<code>attr</code>方法，只能用 prop</p>
<h2 id='3-'>3. 自定义动画</h2>
<pre><code class="lang-javascript">$(selector).animate({ params }, [speed], [easing], [callback]);
</code></pre>
<p><code>params</code>：是个对象，包含需要动画的 css 属性与属性值（必填项），<code>speed</code>：动画时长（可选项），<code>easing</code>：动画运动曲线（可选项）默认 swing（缓动），linear（匀速），<code>callback</code>：动画执行完后回调函数（可选项）</p>
<h2 id="4-">4. 节点操作</h2>
<p><strong>创造节点：</strong><code>$(&quot;&lt;div&gt;this is div&lt;/div&gt;&quot;)</code></p>
<p><strong>添加节点：</strong></p>
<p><code>parent.append(child)/child.appendTo(parent)</code>：把 child 添加到 parent 的子元素最后</p>
<p><code>parent.prepend(child)/child.prependTo(parent)</code>：把 child 添加到 parent 子元素最前</p>
<p><code>node.before(node1)</code>：把 node1 添加到 node 前面</p>
<p><code>node.after(node1)</code>：把 node1 添加到 node 后面</p>
<p><strong>删除节点：</strong></p>
<p><code>remove()</code>：删除自己</p>
<p><code>node.empty()</code>：清空节点，把 node 的所有子元素全部清除</p>
<p><strong>克隆节点：</strong></p>
<p><code>$(selector).clone()</code>：返回值为新的元素，参数为布尔值，true 深克隆，会克隆事件，false 深克隆，不会克隆事件</p>
<h2 id='5-'>5. scroll 与 offset 系列</h2>
<p><code>$(window).scrollTop()</code>：获取滚动条的位置</p>
<p><code>$(&#39;html&#39;).animate({scrollTop:0},2000)</code>：返回顶部</p>
<p><code>$(selector).offset()</code>：获取元素距离 document 的位置，返回值为<code>{left:100,top:100}</code>的对象</p>
<p><code>$(selector).position()</code>：获取相对于最近的有定位的父元素的位置</p>
<h2 id='6-'>6. 显式迭代，each 方法</h2>
<pre><code class="labg-javascript">$(selector).each(function (index, element) {
  // $(this)为遍历的每一个元素
  $(this);
});
</code></pre>
<h2 id="7-">7. 多库共存</h2>
<p>当 jquery 中的$被其他js文件占用，此时我们无法通过$使用 jquery</p>
<pre><code class="lang-javascript">var $$ = $.noConflict(); // 释放$的控制权，用$$替代
</code></pre>
<h2 id="8-lazy-load-">8. 懒加载 Lazy Load（查文档）</h2>
<p>Lazy Load 是一个用 JavaScript 编写的 jQuery 插件。 它可以延迟加载长页面中的图片。 在浏览器可视区域外的图片不会被载入，直到用户将页面滚动到它们所在的位置。在包含很多大图片长页面中延迟加载图片可以加快页面加载速度。 浏览器将会在加载可见图片之后即进入就绪状态。 在某些情况下还可以帮助降低服务器负担。</p>
<p><strong>使用方法：</strong></p>
<p>引入 jQuery.js 和 jquery.lazyload.js</p>
<p>必须改变图片的属性，将图片的 src 属性值放到 data-original 属性。给懒加载图片一个特定的 className（比如 lazy）。图片必须设置宽高</p>
<pre><code class="lang-javascript">&lt;img
  class=&quot;lazy&quot;
  alt=&quot;&quot;
  width=&quot;640&quot;
  height=&quot;480&quot;
  data-original=&quot;img/example.jpg&quot;
/&gt;;

$(function () {
  $(&quot;img.lazy&quot;).lazyload();
});
</code></pre>
<p><strong>自定义的参数：</strong></p>
<p><code>threshold</code>：设置临界点，当图片距离屏幕到达临界点距离时，提前加载，参数为不带单位的数值</p>
<p><code>event</code>：设置事件来触发加载，默认情况是向下滚动到图片的时候加载，也可以设置其他事件</p>
<p><code>effect</code>：设置特效，默认是完全加载并调用<code>show()</code>，也可以自己定义显示方式</p>
<h2 id='9-'>*9. window.onload 和 document ready 的区别</h2>
<p><code>window.onload</code>是在 dom 文档树加载完和所有文件加载完之后执行一个函数<code>Document.ready</code>原生中没有这个方法，jquery 中有<code>$().ready(function)</code>，在 dom 文档树加载完之后执行一个函数（注意，这里面的文档树加载完不代表全部文件加载完）</p>
<p><code>$(document).ready</code>要比<code>window.onload</code>先执行</p>
<p><code>window.onload</code>只能出来一次，<code>$(document).ready</code>可以出现多次</p>
<h2 id='10-'>*10. 什么是防抖和节流，他们的应用场景有哪些</h2>
<p>防抖：防止某个事件因为用户的误操作，一时间内触发多次。在最后一次操作后执行</p>
<p>场景：登录、发送短信按钮避免用户点击过快，防止多次请求；文本编辑器，实时自动保存，在用户停止操作后执行</p>
<pre><code class="lang-javascript">let debounceBtn = document.querySelectorAll(&quot;.debounce-button&quot;)[0];
let throttleBtn = document.querySelectorAll(&quot;.throttle-button&quot;)[0];
//如果防抖节流执行的函数需要传参
debounceBtn.addEventListener(
  &quot;click&quot;,
  debounce(() =&gt; {
    handlerClick(&quot;防抖&quot;);
  }, 5000)
);
throttleBtn.addEventListener(
  &quot;click&quot;,
  throttle(() =&gt; {
    handlerClick(&quot;节流&quot;);
  }, 5000)
);
function handlerClick(str) {
  console.log(str);
}
// 防抖
function debounce(fn, wait) {
  let timer;
  return (...args) =&gt; {
    const that = this;
    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.call(that, ...args);
    }, wait);
  };
}
// 节流
function throttle(fn, wait) {
  let timer;
  let start = 0;
  return (...args) =&gt; {
    let curTime = new Date().getTime();
    if (curTime - start &gt; wait) {
      fn.call(this);
      start = new Date().getTime();
    } else {
      clearTimeout(timer);
      timer = setTimeout(function () {
        fn.call(this, ...args);
        timer = null;
        start = new Date().getTime();
      }, wait);
    }
  };
}
</code></pre>
<h1 id="vue">VUE</h1>
<h2 id="-1-mvvm-">*1. 对于 MVVM 的理解</h2>
<p>MVVM 是 Model-View-ViewModel 的缩写，Model 代表数据层，它仅仅关注数据本身，不关心任何操作行为；View 代表视图层，主要负责展示视图；ViewModel 代表业务逻辑层，View 需要什么数据，ViewModel 就提供这个数据，View 进行了哪些操作，ViewModel 就响应那些操作，这部分是由框架实现，不需要程序员进行开发，就可以自动的实现数据到视图，以及视图到数据的流程。在 vue2.0 的 MVVM 实现中，对 ViewModel 的实现是利用了 ES5 的 Object.defineProperty 方法，当 new Vue 在实例化的时候，首先将 data 方法里返回的对象属性都挂载上 setter 方法，而 setter 方法里将页面上的属性进行绑定，当页面加载的时候哦，浏览器提供的 DOMContentloaded 事件触发后，调用 mounted 挂载函数，开始获取接口数据，获取完成后，给 data 里属性赋值，赋值时触发之前挂载好的 setter 方法，从而引起页面的联动，达到响应式效果。在 Vue3.0 将会使用 Proxy 和 Reflect 来替代 Object.defineProprety 的方式（Proxy 和 Reflect 将在 ES6 的篇章介绍）</p>
<h2 id="-2-proxy-defineproperty-">*2. Proxy 相比于 defineProperty 的优势</h2>
<p>Object.defineProperty 的问题主要有三个：1、不能监听数组的变化；2、必须遍历对象的每个属性；3、必须深层遍历嵌套的对象</p>
<p>而 Proxy 的特点有：1、针对真个对象，而不是对象的某个属性，这样就不需要遍历对象；2、支持数组。Proxy 的第二个参数可以有 13 中拦截方式，比 Object.defineProperty 更加丰富。</p>
<h2 id="3-vue-">3. 常用的 vue 指令</h2>
<p>v-model：表单元素属性与数据双向绑定；</p>
<p>v-if，v-show：条件渲染，v-show 它只是 CSS 中的 display 显示隐藏，HTML 元素仍然是存在的，而 v-if 为 false 的时候，页面中是不会有这个 HTML 元素生成；</p>
<p>v-on：绑定事件的，用@代替；</p>
<p>v-text，v-html：类似 js 中 innerText 和 innerHtml；</p>
<p>v-for：列表渲染；</p>
<p>v-bind：动态绑定一个或多个特性，或一个组件 prop 到表达式，可用：替代；</p>
<h2 id="-4-vue-">*4. Vue 的双向数据绑定原理</h2>
<p>vue 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty 来劫持各个属性的 setter，getter，在数据变化时发布消息给订阅者，触发相应的监听回调。</p>
<p>具体步骤：</p>
<ul>
<li><p>需要 Observer 的数据对象进行递归遍历，包括子属性对象的属性，用 Object.defineProperty 都加上 setter 和 getter。这样的话，给这个对象的某个值赋值时，就会触发 setter，那么就能监听到数据的变化。</p>
</li>
<li><p>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变化，收到通知，更新视图。</p>
</li>
<li><p>Watcher 订阅者是 Observer 和 Compile 之间的通信桥梁，主要做的事情是：</p>
<p>1、在自身实例化的时候往属性订阅者里添加自己；</p>
<p>2、自身必须有一个 update 方法；</p>
<p>3、待属性变动 dep.notice 通知时，能调用自身的 update 方法，并触发 compile 中绑定的回调</p>
</li>
<li><p>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化，视图更新；视图交互变化，数据 model 变化的双向绑定效果</p>
</li>
</ul>
<h2 id="-5-vue-">*5. Vue 的生命周期</h2>
<p>vue 生命周期表示一个 vue 实例从创建到销毁的过程，这个过程一共分成四个阶段，创建阶段，挂载阶段，更新阶段和销毁阶段。<strong>创建阶段</strong>在 new vue()的对象中，先执行了 init，对生命周期中的钩子函数与生命周期进行初始化，在 init 的过程中，我们首先可以调用 beforeCreate 这个钩子函数。然后再把 data 数据通过 object.defineProperty 注入 vue 实例中做成响应式数据，完成之后，我们可以调用 created 钩子函数。在数据初始化并注入完成之后，它会去判断 vue 实例中传入的数据是否有 el 属性，如果没有，它会调用 vm.$mount(el)这个方法，再执行下一步，判断是否含有template属性，如果有，它会编译模板，创建一个render函数，如果没有，则把el对应的html代码编译成模板。此时可以调用beforeMount。然后进入<strong>挂载阶段</strong>，挂载阶段会根据这个模板把我们数据渲染好，渲染完成之后它会创建vm.$el，用这个因创建的元素，把页面的 el 替换，这个时候我们就能看到页面上有数据的 html 元素，此时我们可以调用 mounted。<strong>更新阶段</strong>是当数据发生更新，vue 监听到数据的变化，重新渲染虚拟 DOM 对页面内容进行更新，这个阶段发生前后我们可以调用 beforeUpdate 和 updated。当 vm.$destory()被调用时，就进入<strong>销毁阶段</strong>，销毁阶段会将所有和当前 vue 实例相关的资源释放掉。在销毁阶段前后我们可以调用 beforeDestroy 和 destoryed。这个阶段无法自动把定时器延时器以及异步操作的代码释放掉，所以我们需要手动调用 destoryed 这个钩子函数释放。这样一个 vue 实例的生命周期就完成</p>
<h2 id="6-">6. 事件修饰符</h2>
<p>.stop：阻止事件冒泡；.self：只有自己可以触发；.prevent：阻止事件默认行为；.once：只触发一次；.capture：阻止事件捕获</p>
<h2 id="7-">7. 按键修饰符，系统修饰键自行百度</h2>
<h2 id="8-vue-set-vm-set">8. 向响应式对象中添加一个属性，使属性同样是响应式：Vue.set/vm.$set</h2>
<p>Vue.set(target，propertyName/index，value)</p>
<p>参数：target：Object|Array；propertyName/index：string|number；value：any</p>
<p>因为 Vue 无法探测普通的新增属性，所以必须使用这个方法向响应式对象上添加新属性，向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新</p>
<h2 id="9-vue-nexttick-vm-nexttick">9. 访问更新后的数据：Vue.nextTick/vm.$nextTick</h2>
<p>Vue.nextTick([callback，context])</p>
<h2 id="10-vue-directive">10. 注册或获取全局指令：Vue.directive</h2>
<p>Vue.directive(id，[definition])</p>
<p>directive:{}可以局部注册</p>
<p>钩子函数如下：</p>
<p>insert：当当前指令所在的元素被插入到页面时执行；</p>
<p>bind：当 vue 要对当前指令所在的元素进行解析的时候；</p>
<p>update：当当前指令绑定的数据发生变化的时候；</p>
<p>componentUpdate：当数据改变完成，元素更新完毕之后；</p>
<p>unbind：当指令被卸载的时候</p>
<p>在自定义指令中的钩子函数可以获取的相关信息：</p>
<p>name:当前指令名；rowname:带 V 的指令吗；expression:等号后面的表达式；arg:指令参数； modifiers:指令修饰等，这是一个对象，修饰符都会被作为属性存在这个对象中，属性值为 true；value:表达式的值</p>
<p><img src="./toc/image/binding的属性.png" alt="binding的属性"></p>
<h2 id="11-vue-">11. vue 组件通信之父传子</h2>
<p>父组件中子组件调用，使用 v-bind 绑定传递的值，子组件中 props 里可以获取</p>
<pre><code class="lang-vue">父组件：
&lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt;
&lt;son :msgFromFather=&quot;msg&quot;&gt;&lt;/son&gt;
子组件： export default { props: [&quot;msgFromFather&quot;] };
</code></pre>
<h2 id="12-vue-">12. vue 组件通信之子传父</h2>
<p>子组件触发某个事件，事件里通过$emit 将父组件上的事件与传递的数据绑定，</p>
<p>父组件中子组件绑定一个事件，这个事件就能拿到传递来的数据</p>
<pre><code class="lang-vue">父组件：
&lt;son1 @msgFromSon=&quot;msgFromSon&quot; /&gt;
methods：{ msgFromSon(msg){ // msg为子组件传递来的数据 } 子组件：某个事件里{
this.$emit(&#39;msgFromSon&#39;,this.msg) }
</code></pre>
<h2 id="13-vue-">13. vue 组件通信之兄弟</h2>
<p>入口文件 main.js 创建一个空 vue 实例 bus，同时暴露给 window</p>
<p>兄弟 1，在某个事件中利用 bus.$emit 将传递的数据与事件绑定</p>
<p>兄弟 2，创建阶段，利用 bus.$on 绑定某个事件，事件内拿到传递的数据</p>
<pre><code class="lang-vue">main.js: const bus = new Vue({}) window.bus = bus 兄弟1： 某个事件{
bus.$emit(&#39;aaa&#39;,this.msg) } 兄弟2： created(){ bus.$on(&#39;aaa&#39;,msg=&gt;{ //
msg为传递的数据 }) }
</code></pre>
<h2 id="14-dom-refs">14. 获取 DOM 元素：$refs</h2>
<p>在子组件或者 DOM 元素上加上 ref 属性，属性值为名字，可以通过$refs.名字获取到这个子组件或者 DOM 元素上的数据</p>
<h2 id="-15-vue-router-">*15. vue-router 有哪几种导航守卫</h2>
<ul>
<li><p>全局守卫</p>
<ol>
<li>beforeEach：全局前置守卫，进入路由之前；</li>
<li>beforeResolve：全局解析守卫，beforeRouterEnter 调用之后；</li>
<li>afterRouter：全局后置守卫，进入路由之后；</li>
</ol>
</li>
<li><p>路由独享守卫</p>
<p>如果不想要全局配置守卫，就可以为某些路由单独配置守卫</p>
</li>
<li><p>路由组件内的守卫</p>
<p>主要有三种：beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave。他们直接在路由组件内部进行定义</p>
</li>
</ul>
<h2 id="-16-vue-router-">*16. vue-router 路由的两种模式</h2>
<ol>
<li>hash 模式：在浏览器中符号“#”，“#”以及“#”后面的字符称之为 hash，用 window.location.hash 读取</li>
<li>history 模式：history 采用 HTML5 新特性，且提供了两个新方法：pushState()，replaceState()可以对浏览器的历史记录栈进行修改，以及 popState 事件的监听到状态变更，这个模式需要后台配置支持</li>
</ol>
<h2 id="17-">17. 路由参数的获取</h2>
<p>this.$route.query：获取路由？传递参数；</p>
<p>this.$route.params：获取动态路由传递的参数/:id/:name/:age</p>
<h2 id="18-vue-cli-">18. vue-cli 脚手架</h2>
<p>安装：npm i -g @vue/cli</p>
<p>创建项目：vue create 项目名</p>
<h2 id="19-v-slot-">19. v-slot 插槽自行百度</h2>
<h2 id="20-prop-">20. prop 类型校验</h2>
<p>开发组件供他人使用时，我们给需要的 prop 的值指定类型，避免他人传入错误类型的数据</p>
<p>一般我们看到的 prop 都是以字符串数组形式列出</p>
<pre><code class="lang-vue">props:[&#39;title&#39;,&#39;like&#39;,&#39;isPublished&#39;]
</code></pre>
<p>指定类型时，以对象形式列出</p>
<pre><code class="lang-vue">props:{ title:String, //多个类型 like:[String,Number], //必须的布尔值
isPublished:{ type:Boolean, required:true }, //带默认值 num：{ type:Number,
default:100 } }
</code></pre>
<h2 id="21-v-model-sync-">21. 当无法使用 v-model，使用.sync 修饰符</h2>
<p>使用 v-bind 绑定属性，然后使用.sync 修饰符，也可以实现双向绑定</p>
<pre><code>:msg.sync=&quot;msg&quot;
</code></pre><h2 id="-22-vue-computed-">*22. Vue 里面 computed 是什么东西怎么用</h2>
<p>在 vue 模板中使用表达式是非常便利的，但设计它的初衷是用来进行简单运算的。在实际开发中在模板里放入过多的表达式会使项目的可维护性大大降低。对于复杂计算的数据，我们就使用计算属性来解决，当计算属性中的值发生变化的时候，计算属性也会更新</p>
<h2 id="-23-vue-watch-">*23. Vue 里面的 watch 是什么东西怎么用</h2>
<p>实际开发过程中需要一些自定义的监听器，当需要在执行异步或者一些开销比较大的操作中，监听器会比计算属性更加有效</p>
<h2 id="-24-watch-computed-">*24. watch 和 computed 的区别</h2>
<p>计算属性和监听属性都是希望在依赖数据发生变化的时候，被依赖的数据根据事先设定好的函数发生自动的变换。</p>
<p>watch 我们需要一个数据发生变化的时候进行一些操作时使用</p>
<p>computed 我们需要一个数据，它是由某些数据经过运算得到的</p>
<h2 id="-25-vue-keep-alive-">*25. vue 中 keep-alive 组件的作用</h2>
<p>主要用于保留组件状态或避免重新渲染，组件切换调用的时候本身会被销毁掉，只要加上 keep-alive 进行包裹，就不会被销毁，而是被缓存起来，下一次使用的时候就会从缓存中快速渲染，而不是重新渲染</p>
<h2 id="-26-vue-data-">*26. vue 组件里面 data 为什么必须是一个函数</h2>
<ol>
<li>如果使用的 data 是一个对象，那么每次创建组件实例的时候，都会引用这个 data 对象，所有实例用到的都是同一个，又由于 data 对象是一个引用类型的数据，那么就会导致，一个实例里面对 data 修改，其他实例都会受到影响。</li>
<li>如果 data 是个函数，那么在每次创建组件实例的时候，都会调用这个函数，生成一个新的对象，那么所有的对象都有自己独立的 data，互相不影响</li>
</ol>
<h2 id="27-filter">27. 过滤器 filter</h2>
<p>常用于处理数据，文本格式化。用在<strong>双花括号插值</strong>和<strong>v-bind 表达式</strong>用|代替</p>
<pre><code class="lang-vue">{{ message | captalize }}
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre>
<p>局部注册</p>
<pre><code class="lang-vue">filters：{ captalize：function(value){ if(!value) return &quot;&quot; return &#39;123&#39;+value }
}
</code></pre>
<p>全局注册</p>
<pre><code class="lang-vue">Vue.filter(&#39;formatId&#39;,function(id){ if(!id) return &quot;&quot; return &#39;2020&#39;+id })
</code></pre>
<h1 id="vuex">VUEX</h1>
<h2 id="-1-vuex-">*1. Vuex 是什么？怎么使用？哪些功能场景使用它？</h2>
<p>Vuex 是专门为 Vue 应用程序开发的状态管理器，采用集中式存储管理应用的所有组件的状态。</p>
<p>state：Vues Store 实例的根状态对象，用于定义共享的状态变量；</p>
<p>action：向 store 发出调用通知，执行本地或者远端的某一个操作；</p>
<p>mutaions：只用于修改 state 中定义的状态变量；</p>
<p>getter：外部程序通过它获取变量的具体值，或者在取值前做一些计算；</p>
<p>使用场景：</p>
<ul>
<li>数据需要在多个组件里面来回调用</li>
<li>全局都要使用的方法，并且方法是需要保存不被浏览器清理掉</li>
<li>组件需要保存的数据</li>
</ul>
<h2 id="-2-vuex-">*2. VueX 页面刷新数据丢失问题怎么解决</h2>
<ul>
<li>使用 localStorage 实时保存 vuex 数据</li>
<li>使用 vuex-along 插件</li>
</ul>
<h2 id="3-vuex-">3. VueX 的创建</h2>
<p>安装：npm i vuex</p>
<p>在 src 文件夹中创建一个 store 文件夹，里面 index.js 文件</p>
<pre><code class="lang-vue">import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; import modules from &#39;./modules&#39;
import state from &#39;./state&#39; import getters from &#39;./getters&#39; import actions from
&#39;./actions&#39; import mutations from &#39;./mutations&#39; Vue.use(Vuex) const store = new
Vuex.Store({ modules, state, getters, actions, mutations,
strict:process.env.NODE_ENV !==&#39;production&#39; }) export default store
</code></pre>
<p>在 main.js 中引入 store，在 vue 实例中加入 store</p>
<h2 id="4-state">4. State</h2>
<p>state 用来存储数据的，通过 this.$store.state 获取 vuex 储存的数据</p>
<pre><code>export default({})
</code></pre><h2 id="5-getters">5. getters</h2>
<p>getters 类似计算属性</p>
<pre><code class="lang-vue">const getters = { doneTodos: state=&gt;{ return state.todos.filter(todo=&gt;todo.done)
} } export default getters
</code></pre>
<p>getters 可以传参，但因为 getters 已经有一个参数 state 了，所以我们通过返回一个函数来传递参数</p>
<pre><code class="lang-vue">const getters={ getTodoById:state=&gt;id=&gt;{ return
state.todos.find(todo=&gt;todo.id===id) } }
</code></pre>
<h2 id="6-mutations">6. mutations</h2>
<p>处理数据的方法（同步）</p>
<p>页面中通过 this.$store. (&#39;函数名&#39;，参数)来触发对应的 mutations</p>
<p>mutations 中的处理函数有两个参数：第一个 state，第二个为传入的参数</p>
<pre><code class="lang-vue">export default{ chang(state,data){ state.data=data } }
</code></pre>
<h2 id="7-actions">7. actions</h2>
<p>actions 可以进行异步方法，实际提交的还是 mutations，而不是直接修改状态 state</p>
<p>actions 中接收一个与 store 实例具有相同方法和属性的 context 对象，context.commit(&#39;函数名&#39;，参数)</p>
<p>同样的，可以使用 context.state 与 context.getters</p>
<p>页面中通过 this.$store.dispatch(&#39;函数名&#39;，参数)</p>
<pre><code class="lang-vue">//action.js getDate(context,params)=&gt;{ return new Promise((resolve,reject)=&gt;{
api.getDateApi(params)//请求 .then(res=&gt;{ context.commit(&#39;GETDATE&#39;,res.body)
resolve(res.body) }) .catch(err=&gt;{ reject() }) }) } //vue中
this.$store.dispatch(&#39;getDate&#39;,params)
</code></pre>
<h2 id="8-modules">8. modules</h2>
<p>Vuex 允许我们将 store 分割成 module，每个模块都有自己的 state，mutations，actions，getters</p>
<pre><code class="lang-vue">// 每个模块自己的store // modules里面的index.js import moduleA from &#39;./moduleA&#39;
import moduleB from &#39;./moduleB&#39; const store = { moduleA, moduleB } export
default store
</code></pre>
<h2 id="9-mapstate-mapgetters-mapactions-mapmutations">9. mapState，mapGetters，mapActions，mapMutations</h2>
<p>每次组件中调用 state，getters，actions，mutations 都要写一个方法或者属性，然后通过$store 调用，<strong>非常麻烦</strong>。</p>
<pre><code class="lang-vue">//引入 import {mapState，mapGetters，mapActions，mapMutations} from vuex // 调用
computed：{ ...mapState([&quot;数据名称&quot;])， ...mapGetters([&quot;数据名称&quot;]) } methods：{
...mapActions([&quot;方法名&quot;]), ...mapMutations([&quot;方法名&quot;]) }
</code></pre>
<h1 id="react">React</h1>
<h2 id="-1-real-dom-virtual-dom-">*1. Real Dom 和 Virtual Dom 的区别</h2>
<p>Virtual（虚拟）DOM 是对 Real（真实）DOM 的一种模拟，相对于直接操作真实的 DOM 结构，我们构建一棵虚拟 DOM 树，将各种数据和操作直接应用在这棵虚拟 DOM 树上，然后再将虚拟 DOM 树的修改应用到真实 DOM 结构上。</p>
<p>即使我们频繁操作虚拟 DOM，我们只需要一定时刻一次性同步修改到真实 DOM 上，这样减少了 DOM 操作次数，性能上得到了提升。</p>
<p>虚拟 DOM 无法直接更新 HTML，如果元素更新，也只是更新 JSX，而不是创建新的 DOM，所以内存消耗更少。</p>
<p>虚拟 DOM 最大的优点是它不依赖浏览器环境，能在 node 环境实现，可以使用虚拟 DOM 生成 html 字符串，实现 SSR 服务端渲染。</p>
<h2 id="-2-ssr-">*2. SSR 服务端渲染</h2>
<p>SSR 目的是为了解决 SEO 的问题，对于一般的页面来说 SEO 对于页面的影响不是很大，但是对于一些新闻，论坛类网站来说是致命的，因为框架类项目打包生成的页面是没有办法进行 SEO 的，所以他们的关键信息没有办法暴露出来。SSR 的原理就是将框架类型的页面交给后端在服务器来渲染，然后发送到客户端，从而实现 SEO</p>
<h2 id="-3-react-react-">*3. 什么是 React，React 有什么特点，主要优点</h2>
<p><strong>React</strong>是由 Facebook 内部的一个 JavaScript 库，用于构建用户界面，React 本质上只关心两件事：1.更新 DOM；2.响应事件。它不处理 ajax、路由和数据储存，所以从 MVC 的角度，它更像是 MVC 中的 V，视图层</p>
<p><strong>React 的特点</strong></p>
<ol>
<li>声明式设计，只需要描述页面的样子，React 负责更新页面。</li>
<li>React 使用虚拟 DOM，最大限度的减少与 DOM 的交互。可以对虚拟 DOM 多次操作，而只需要一次同步修改到真实 DOM 上，提升性能。</li>
<li>它不依赖浏览器环境，能在 node 环境实现，所以可以用在服务器端渲染。</li>
<li>通过 React 构建组件，使得代码更加容易复用，能够很好的应用在大项目开发中。</li>
<li>遵循单向数据流。</li>
</ol>
<p><strong>主要优点</strong></p>
<ol>
<li>提高了应用的性能</li>
<li>方便在客户端与服务器端使用</li>
<li>由于使用了 JSX，代码可读性很好</li>
</ol>
<h2 id="-4-jsx">*4. 什么是 JSX</h2>
<p>JSX 本质上就是 JavaScript 中的对象，虽然 JSX 看起来像 HTML，但实际只是一种更加方便的创建模板的方式，底层实际上转化为 React.createElement()来编写声明。当组件渲染时，JSX 会表示成 DOM 节点的抽象描述，并最终转化为实际的 DOM 进行渲染</p>
<h2 id="-5-virtual-dom-">*5. 你了解 Virtual Dom 吗？解释一下它的工作原理</h2>
<p>虚拟 DOM 本质是一个 JavaScript 对象，它最初只是真实 DOM 的副本，它是一个节点树。</p>
<p>工作原理简单的三步：</p>
<ol>
<li>当底层数据发生变化时，重新根据新的数据创建新的虚拟 DOM 树。</li>
<li>然后与之前的虚拟 DOM 对象，进行 diff 算法对比，找到之间的差异，得到需要更新的内容。</li>
<li>最终根据变化的内容更新真实 DOM。</li>
</ol>
<h2 id="-6-diff-">*6. diff 算法</h2>
<ol>
<li>如果两个根元素类型不同，React 会销毁旧树，创建新树。</li>
<li>对于类型相同的 React DOM 元素，React 会对比两者的属性是否相同，只更新不同的属性，当处理完这个 DOM 节点，React 会递归处理子节点。</li>
<li>在子节点后面添加一个节点，React 对前面的子节点原封不动在它后面创建一个节点，但如果在开始位置插入一个元素，则会删除第一个然后新建一个，第二个不一样又接着删除重建，以此类推。改变每一个不同的节点，而不是复用。</li>
</ol>
<p>所以 React 提供了一个 key 属性，React 会通过 key 来匹配原始树和后来的树。</p>
<h2 id="-7-jsx">*7. 为什么浏览器无法读取 JSX</h2>
<p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先需要使用像 babel 这样的 JSX 转换器将 JSX 文件转换成 JavaScript 对象，然后再将其传给浏览器</p>
<h2 id="-8-react-render-">*8. 解释 React 中 render()的目的</h2>
<p>每个 React 组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标签内。此函数必须保持纯净，即必须每次调用时都返回相同的结果。</p>
<h2 id="-9-props">*9. 什么是 props</h2>
<p>props 是一个从外部传进组件的参数，主要作为从父组件向子组件传递数据，它具有只读性和不变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展示形式不会改变</p>
<h2 id="-10-react-">*10. React 中的状态是什么？它是如何使用的</h2>
<p>状态 state 主要作用是用于组件保存、控制以及修改自己的状态，它只能在 constructor 中初始化，它是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改，修改 state 属性会导致组件的重新渲染</p>
<h2 id="-11-setstate-">*11. 调用 setState 之后都发生了什么</h2>
<p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就是保证了按需求更新，而不是全部重新渲染</p>
<h2 id="-12-react-">*12. React 中什么时候是同步的，什么时候是异步的？</h2>
<p>在 React 中，如果是由 React 引起的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会立即更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的时间处理函数，还有通过 setTimeout/setInterval 产生的异步调用。</p>
<p>原因：在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放在队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是有 React 控制的事件处理过程 setState 不会同步更新 this.state</p>
<h2 id="-13-react-">*13. React 中的箭头函数是什么？怎么用</h2>
<p>箭头函数是 ES6 中的一种用于编写函数表达式的简短语法。箭头函数不会在函数体内重新定义 this 的值，所以在回调中的 this 指向更容易预测。将像 setState 放在处理函数中时，this.setState()的 this 是指向 undefined。此时用箭头函数可以解决这个问题</p>
<h2 id="-14-">*14. 有状态组件与无状态组件</h2>
<p>有状态组件主要用来定义交互逻辑和业务逻辑，有自己的状态，负责更新；</p>
<p>无状态组件主要用于定义模板，将接收来的数据展示出来</p>
<h2 id="-15-react-">*15. React 组件生命周期的阶段是什么</h2>
<p>React 组件的生命周期有三个不同的阶段</p>
<ol>
<li><p><strong>挂载阶段</strong>：当组件实例被创建并插入 DOM 中时，其生命周期调用顺序</p>
</li>
<li><p>getDefaultProps()：获取实例的默认属性</p>
</li>
<li>getInitialState()：获取每个实例的初始化状态</li>
<li>constructor()：为生命周期的钩子函数绑定 this</li>
<li>componentWillMount()：组件即将被挂载、渲染到页面上</li>
<li>render()：组件在这里生成虚拟的 DOM 节点，这里不能调用 setState，因为每次调用 setState 都会重新渲染</li>
<li><p>componentDidMount()：组件真正在被挂载之后，仅在第一次渲染后在客户端执行，这个时候我们可以发送网络请求，并进行 DOM 操作</p>
</li>
<li><p><strong>更新阶段</strong>：当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序：</p>
</li>
<li><p>componentWillReceiveProps()：组件将要接收到属性的时候调用</p>
</li>
<li>shouldComponentUpdate()：组件接收到新属性或者新状态的时候</li>
<li>render()：组件重新描绘</li>
<li><p>componentDidUpdate()：组件已更新时，这个时候我们也可以发送网络请求，并进行 DOM 操作，这里也可以调用 setState 方法，但要做个 if 判断，防止一直更新，调死程序</p>
</li>
<li><p><strong>卸载阶段</strong>：当组件从 DOM 中移除时，调用</p>
</li>
<li><p>componentWillUnmount()：组件即将销毁，用于清理内存空间，比如定时器</p>
</li>
</ol>
<h2 id="-16-react-">*16. 详细解释 React 组件的生命周期方法</h2>
<ul>
<li><strong>componentDidMount()</strong>：仅在第一次渲染后在客户端执行，这个时候我们会发送网络请求或者进行 DOM 操作</li>
<li><strong>shouldComponentUpdate()</strong>：根据特定条件返回 true 或 false。如果你希望更新组件，就返回 true</li>
<li><strong>componentDidUpdate()</strong>：在渲染发生后立即调用，这个时候我们会发送网络请求或者进行 DOM 操作</li>
<li><strong>componentWillUnmount()</strong>：从 DOM 卸载组件后调用。用于清理内存空间，比如定时器</li>
</ul>
<h2 id="17-componentdidupdate">17. componentDidUpdate</h2>
<pre><code class="lang-jsx">componentDidUpdate(prevProps,prevState,snapshot){
    if(this.props.id !== prevProps.id){
        this.fetchData(this.props.id)
    }
}
</code></pre>
<h2 id="18-shouldcomponentupdate">18. shouldComponentUpdate</h2>
<pre><code class="lang-jsx">shouldComponentUpdate(nextProps,nextState){
    if(this.props.id !== nextProps.id){
        return true
    }
    return false
}
</code></pre>
<h2 id="-19-react-">*19. React 中的合成事件是什么</h2>
<p>如果 DOM 上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React 为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——合成事件</p>
<p>原理：React 并不是将事件绑定在真实 DOM 上，而是在 document 处监听所有支持的事件，当事件发生并冒泡到 document 处时，React 将事件内容封装并交由真正的处理函数运行。React 的事件对象并不是真实的原生事件对象，而是通过合成的方式实现了一个包含原生事件特性的模拟对象，但是可以实现相同的功能</p>
<h2 id="-20-react-refs-">*#20. 你对 React 的 refs 有什么了解</h2>
<p>refs 提供了一种方式，允许我们访问 DOM 节点或者在 render 方法中创建的 React 元素</p>
<pre><code class="lang-jsx">// 创建refs
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return &lt;div ref={this.myRef} /&gt;;
  }
}
// 访问ref
const node = this.myRef.current;
</code></pre>
<p>关于 ref 曾在工作中遇到 bug，当时需要获取到 DOM 元素，想到了 ref 这个方法，满心欢喜的敲下代码后，控制台报错</p>
<pre><code class="lang-javascript">_WEBPACK_IMPORTED_MODULE_0_recat_default.a.creatRef is not a function
</code></pre>
<p>createRef 不是一个方法？苦思冥想，借鉴百度，最后定位到问题是这个方式是 React16.3+才有的，而公司在用的 React 版本还是 16.2.0</p>
<p>于是使用不了这个高大上的方法了，下面是 React16.2.0 使用 ref 的代码</p>
<pre><code class="lang-jsx">// 创建refs
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return &lt;div ref=&quot;myRef&quot; /&gt;;
  }
}
// 访问ref
const node = this.refs.myRef;
</code></pre>
<p>网上还有一种 callback 的 ref 形式</p>
<pre><code class="lang-jsx">// 创建refs
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      &lt;div
        ref={ele =&gt; {
          this.myRef = ele;
        }}
      /&gt;
    );
  }
}
// 访问ref
const node = this.myRef;
</code></pre>
<p><strong>refs 与函数组件</strong>（自行百度）</p>
<h2 id="-21-">*21. 受控组件与非受控组件</h2>
<ul>
<li><p>受控组件无法维持自己的状态，数据由父组件控制，通过 props 获取当前值，并通过回调通知更改</p>
</li>
<li><p>表单的 value 值存在 state 上</p>
</li>
<li>表单元素绑定一个 change 事件，通过 e 获取 DOM，修改 state 值</li>
</ul>
<p>多个表单元素优化</p>
<ol>
<li>每个表单元素定义一个 name 属性</li>
<li>所有表单元素的 change 事件指向同一个处理函数</li>
<li>处理函数通过 e.target 结果出 name 和 value 属性，this.setState({[name]:value})</li>
<li><p>如果表单中有复选框，我们需要通过 target.type === &#39;checkbox&#39;？checked：value</p>
</li>
<li><p>非受控组件保持着自己的状态，数据由 DOM 控制，用 refs 获取当前值</p>
<p>参见 refs</p>
</li>
</ol>
<h2 id="22-react-">22. React 组件通信之父传子</h2>
<pre><code class="lang-jsx">// 父组件
&lt;Child name={this.state.name} /&gt;;
// 子组件
const name = this.props.name;
</code></pre>
<h2 id="23-react-">23. React 组件通信之子传父</h2>
<pre><code class="lang-jsx">// 子组件
class Child extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      msg: &quot;告诉父亲的话&quot;
    };
  }
  handleClick = () =&gt; {
    this.props.getMsg(this.state.msg);
  };
  render() {
    return &lt;button onClick={this.handleClick}&gt;点我，传数据&lt;/button&gt;;
  }
}
// 父组件
class Parent extends React.component {
  getChildMsg = value =&gt; {
    // value为子组件传递来的数据
  };
  render() {
    return &lt;Child getMsg={this.getChildMsg} /&gt;;
  }
}
</code></pre>
<h2 id="24-react-">24. React 组件通信之兄弟通讯</h2>
<p>状态提升，子 1 传父父传子 2</p>
<h2 id="25-react-context-">25. React 组件通信之 context 跨组件</h2>
<ol>
<li>创建 context 并从中解构出 Provider,Consumer</li>
</ol>
<pre><code class="lang-jsx">const { Provider, Consumer } = React.createContext();
</code></pre>
<ol start="2">
<li>用 Provider 包裹发送数据的组件，并给一个 value 属性</li>
</ol>
<pre><code class="lang-jsx">&lt;Provider value = {数据}&gt;
</code></pre>
<ol start="3">
<li>用 Consumer 包裹接收数据的组件</li>
</ol>
<pre><code class="lang-jsx">&lt;Consumer&gt;{data =&gt; &lt;p&gt;{data}&lt;/p&gt;}&lt;/Consumer&gt;
</code></pre>
<p>自行百度，Redux 真香</p>
<h2 id="26-props-">26. Props 深入</h2>
<ol>
<li><p><strong>children 属性</strong>：获取组件标签的子节点，children 与 props 属性相同，可以为任意值（文本、react 元素、组件甚至是函数）</p>
</li>
<li><p><strong>props 效验</strong>：封装公共组件时，约定添加 props 效验</p>
<p>安装：yarn add prop-types</p>
</li>
</ol>
<pre><code class="lang-jsx">import PropTypes from &quot;prop-types&quot;;
class Greeting extends React.Component {
  render() {
    return &lt;h1&gt;{this.props.name}&lt;/h1&gt;;
  }
}
Greeting.propTypes = {
  name: PropTypes.string.isRequired
};
</code></pre>
<ol start="3">
<li><strong>props 默认值</strong>：通过 defaultProps 定义 props 默认值</li>
</ol>
<pre><code class="lang-jsx">Greeting.defaultProps = {
  name: &quot;John&quot;
};
</code></pre>
<h2 id="27-react-router">27. React-router</h2>
<p>安装 yarn add react-router-dom</p>
<pre><code class="lang-jsx">import {
  BrowserRouter as Router,
  Switch,
  Route,
  Link,
  Redirect
} from &quot;react-router-dom&quot;;
export default function App() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user&quot;&gt;Users&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;Switch&gt;
          &lt;Route path=&quot;/about&quot;&gt;
            &lt;About /&gt;
          &lt;/Route&gt;
          &lt;Route path=&quot;/user&quot; Component&gt;&lt;/Route&gt;
          &lt;Route path=&quot;/&quot;&gt;
            &lt;Home /&gt;
          &lt;/Route&gt;
        &lt;/Switch&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  );
}
</code></pre>
<p>精确匹配，Route 组件添加 exact 属性</p>
<h2 id="-28-hoc-">*28. 什么是高阶组件（HOC）</h2>
<p>高阶组件是 React 中用于复用组件逻辑的一种技巧，高阶组件的参数为组件，返回值为新组件的函数</p>
<h2 id="-29-hoc-">*29. 能用 HOC 做什么</h2>
<ul>
<li>代码复用，逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>状态抽象与控制</li>
<li>Props 控制</li>
</ul>
<p>具体用法自行百度</p>
<h2 id="-30-">*30. 什么是纯组件</h2>
<p>React.,PureComponent，与 React.Component 很类似，区别在于纯组件内部自动实现了 shouldComponentUpdate()这个钩子函数。内部通过分别比较前后两次的 props 和 state 值，来决定是否重新渲染组件。纯组件中的 shouldComponentUpdate()仅作对象的浅层比较，但对于引用类型这种复杂的数据结构，只是比较对象引用地址是否相同</p>
<h2 id="31-react-">31. 创建 React 项目</h2>
<p><code>npx create-react-app 项目名</code></p>
<h2 id="32-antd-mobile-bug">32. Antd-Mobile 的 bug</h2>
<ol>
<li><p>动态添加的轮播图不自动播放：原因是需要默认数据才能轮播，轮播图刚挂载的时候没有数据，所以无法自动播放</p>
<p>解决办法：给一个标记，数据加载好之后，标记置为 true，为 true 就挂载轮播图</p>
</li>
<li><p>手动轮播图时，报错：</p>
<p>解决办法：样式中*{touch-action:pan-y}</p>
</li>
</ol>
<h2 id="-33-react-errorboundary-">*33. 了解 React 中的 ErrorBoundary 吗，它有那些使用场景</h2>
<p>错误边界，是一种 React 组件，这种组件可以捕获并打印发生在某子组件树任何位置的 javaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。</p>
<pre><code class="lang-react">class ErrorBoundary extends React.Component {
    constructor(props){
        super(props)
        this.state = {hasError:false}
    }
    static getDerivedStateFromError(error){
        // 未来可能弃用componentDidCatch，改用这个属性
    }
    componentDidCatch(error,errorInfo){
        // 可以获取error，errorInfo，将错误日志上报到服务器
        render(){
            if(this.state.hasError){
                // 自定义错误后的UI并渲染 return &lt;h1&gt;Something went wrong.&lt;/h1&gt;
                return this.props.children
            }
        }
    }
}

// 这个组件可以作为常规组件去使用
&lt;ErrorBoundary&gt;
  &lt;MyWidget /&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
<h1 id="react-hooks">React Hooks</h1>
<h2 id="1-hooks-">1. 理解 hooks 的思想</h2>
<ol>
<li><p>前端通过函数 f 将 data 数据映射到 UI 用户界面就是视图，视图上面一些行为会修改数据</p>
<p><img src="./toc/image/图片1.png" alt=""></p>
</li>
<li><p>数据可以分为受行为影响的数据也就是状态 state，还是不会变化的数据也就是属性。</p>
<p><img src="./toc/image/图片2.png" alt=""></p>
</li>
<li><p>状态影射了行为，那我们把行为封装在状态里，视图只是感知状态的变化从而更新视图。</p>
<p><img src="./toc/image/图片3.png" alt=""></p>
</li>
<li><p>在视图与状态之间还有一些作用，比如<code>window.location.href</code>，还有埋点，将前端的数据发送到服务端。这些作用不会去改变状态，但它需要上下文 context 去理解状态，然后根据状态去产生作用</p>
<p><img src="./toc/image/图片4.png" alt=""></p>
<p><img src="./toc/image/图片5.png" alt=""></p>
</li>
</ol>
<pre><code class="lang-javascript">函数 V= f(props,state){...}
UI = V usehook1() usehook2()...
</code></pre>
<h2 id="-2-react-hooks-">*2. 有没有使用过 react hooks，它带来了那些便利</h2>
<ol>
<li>React 在组件之间复用状态逻辑很难。可能需要使用高阶组件和 render props，但这样需要重新组织组件结果，很麻烦并且会使代码难以理解，还会形成“嵌套地狱”。</li>
<li>React 中一些状态逻辑和副作用会充斥在整个组件，<code>componentDidMount</code>和<code>componentDidUpdate</code>常被用来获取数据。但同时<code>componentDidMount</code>会设置一些事件监听或者定时器，之后有需要在<code>componentWillUnmount</code>中清除。相关的代码被进行了拆分，而不相关的代码又在同一个方法中组合到一起。逻辑不是很清晰。</li>
<li>class 中 this 指向问题。</li>
</ol>
<h2 id="-3-react-hooks-">*3. 如何使用 react hooks 实现一个计数器的组件</h2>
<pre><code class="lang-react">import React,{useState,useEffect} from &#39;react&#39;
function Count (props) {
    const [count,setCount] = useState(0)
    useEffect(()=&gt;{
        const timer = setInterval(()=&gt;{
            setCount(count=&gt;count+1)
        },1000)
        return ()=&gt;{
            clearInterval(timer)
        }
    },[])
    return (
            &lt;div&gt;{count}&lt;/div&gt;
    )
}
export default Count
</code></pre>
<h2 id="4-useeffect-async-await">4. useEffect 中如何使用 async/await</h2>
<p><code>useEffect</code>里面无法使用<code>async/awit</code></p>
<p>转换思想，把<code>async/await</code>的方法封装成一个函数，<code>useEffect</code>里面调用即可</p>
<h1 id="Redux">Redux</h1>
<h2 id='1-'>*1. 核心概念</h2>
<p>store，state，action，reducer</p>
<p>store 保险箱记录所有的状态 state</p>
<p>需要改变的时候需要告诉 dispatch 要干什么 action</p>
<p>处理变化的 reducer 拿到 state 和 action 生成新的 state</p>
<h2 id='2-'>2. connect()</h2>
<p>组件通过 connect 方法自动生成容器组件</p>
<pre><code class="lang-react">import { connect } from &#39;react-redux&#39;
class List extends React.Component{}
export default connect(
    mapStateToProps,
    mapDispatchToProps
)(List)</code></pre>
<h2 id='3-'>3. mapStateToProps()</h2>
<p>它是一个函数，建立一个从（外部的）state 对象到（组件的）props 对象的映射关系</p>
<pre><code class="lang-react">const mapStateToProps = (state) =&gt;{
    return {
        ...state.listReducer
    }
}</code></pre>
<p>这里的 reducer 单独做了个 reducer.js，来管理所有组件的 reducer</p>
<pre><code class="lang-react">import { combineReducer } from &#39;redux&#39;
import homeReducer from &#39;../container/Home/reducer&#39;
import listReducer from &#39;../container/List/reducer&#39;
export default combineReducer({
    homeReducer,
    listReducer
})</code></pre>
<h2 id='4-'>4. mapDispatchToProps()</h2>
<p>建立组件的参数到 store.dispatch 方法的映射。它定义了哪些用户的操作应该当做 Action，传给 store</p>
<pre><code class="lang-react">import {bindActionCreators} from &#39;redux&#39;
import * as action from &#39;./action&#39;
const mapDispatchToProps = dispatch =&gt; {
    return {
        Actions:bindActionCreators(action,dispatch)
    }
}</code></pre>
<h2 id='5-'>5. &lt;Provider&gt; 组件</h2>
<p>connect 方法生成容器组件以后，需要让容器组件拿到 state 对象，才能生成 UI 组件的参数，React-redux 提供 Provider 组件</p>
<pre><code class="lang-react">import { Provider } from &#39;react-redux&#39;
import { createStore } from &#39;redux&#39;
import configureStore from &#39;./store&#39;
const store = configureStore()
render(
    <Provider store={store}>
        <App />
    </Provider>
    document.getElementById(&#39;root&#39;)
)</code></pre>
<pre><code class="lang-react">// store.js
import { createStore，applyMiddleware } from &#39;redux&#39;
import thunkMiddleware from &#39;redux-thunk&#39;
import rootReducer from &#39;../config/reducer&#39;
const configureStore = (initialState) =&gt; createStore(
    rootReducer,
    initialState,
    applyMiddleware(thunkMiddleware)
)
export default configureStore</code></pre>
<h2 id='6-'>6. action</h2>
<pre><code>import request from &#39;../../utils/request&#39;
import {api} from &#39;../../utils/api
import {GET_DATA} from &#39;./constant&#39;
export const getData = params =&gt; {
    return (dispatch,getState)=&gt;{
        let _promise =
        request(&#39;get&#39;,api,parmas).promise
        _promise.then(res=&gt;{
                   if(res.resultCode === 10000){
                    dispatch({
                        type:GET_DATA,
                        data:[...res.body]
                    })
                   }
            }
        ).catch(err=&gt;{
               ......
        })
    }
}</code></pre>
<h2 id='7-'>7. reducer</h2>
<pre><code>import {GET_DATA} from &#39;./constant&#39;
const initialState = {
    data:[]
}
export default (state= initialState,action)=&gt;{
    switch(action.type) {
        case &#39;GET_DATA&#39;:
        return {
            ...state,
            data：action.data,
            type:action.type
        };
        default:
        return {
            ...state
        }
    }
}</code></pre>
<h1 id="axios">axios</h1>
<h2 id='1-'>1. 自己封装的请求方式</h2>
<pre><code class="lang-javascript">// env.js 配置环境
const stage = &#39;stage&#39; // 测试
const prod = &#39;prod&#39; // 生产
const web = &#39;web&#39; // h5
const native = &#39;native&#39;
const env = web
const STAGE_NAME =
const PROD_NAME =
const LOCAL_NAME = &#39;localhost&#39;
const PREPOINT = window.location.origin
const webAdaptive = () =&gt; {
    switch(window.location.hostname){
        case PROD_NAME:
        return: 生产请求地址；
        case STAGR_NAME:
        case LOCAL_NAME:
        default:
        return:测试请求地址；
    }
}
const prefixAdaptive = env =&gt; {
    let prefix = &#39;&#39;
    switch(env){
        case stage:
        return prefix = 测试地址
        case prod:
        return prefix = 生成地址
        case web:
        return prefix = webAdaptive()
        ......
    }
}
export {env,STAGE_NAME,PROD_NAME,LOCAL_NAME,PREPOINT}
export default prefixAdaptive</code></pre>
<pre><code class="lang-javascript">// request.js
import prefixAdaptive,{env} from &#39;../config/env&#39;
const prefix=prefixAdaptive(env)
Promise.prototype.done = function(onFulfilled,onRejected){
    this.then(onFulfilled).catch(function(reason){
        setTimeout(()=&gt;{
            throw reason
        },0)
    })
}
const resolveQuery = params =&gt; {
    let p = &#39;?&#39;
    for (let k in params){
        if(params.hasOwnProperty(k)){
            p+=k+&#39;=&#39;+params[k]+&#39;&amp;&#39;
        }
    }
    p = p.slice(0,-1)
    return p
}
const request = (type,path,parmas)=&gt;{
    let promise = new Promise((resolve,reject)=&gt;{
        type =
        typeof type ===&#39;string&#39;&amp;&amp;type.toUpperCase()
        params = params||{}
        let url = path
        switch(true){
            case type === &#39;GET&#39;:
            let query = resolveQuery(params)
            url = <code>${prefix}${url}${query}</code>
            break;
            case type === &#39;POST:
            url = <code>${prefix}${url}</code>
            break;
        }
        const execute = ()=&gt;{
            const handler = function(){
                if(this.readyState !==4) return
                if(this.status === 200||this.state ===304){
                 resolve(this.response)
                }else if(this.state === 401){
                   // 处理401
                }else {
                    // 处理异常
                    reject()
                }
            }
            let client = new XMLHttpRequest()
            client.open(type,url)
            client.onreadystatechange = handler
            client.responseType = &#39;json&#39;
            // 设置请求头
            client.setRequestHeader()
            // 设置请求体
            client.send(type===&#39;POST&#39;?JSON.stringify(params):null)
        }
        execute()
    })
    return {
        promise:promise,
      }
    }
export default request</code></pre>
<h2 id='2-'>2. axios</h2>

<pre><code class="lang-javascript">import axios from &#39;axios&#39;
import {prefixAdapter} from &#39;../../config/env&#39;
const API = axois.create({
    baseURL:prefixAdapter(),
    timeout:5000 // 请求超时时间
})
// 请求拦截器
API.interceptors.request.use(
    config=&gt;config,
    err=&gt;{
        Promise.reject(err)
    }
)
// 响应拦截器
API.interceptors.response.use(
    res=&gt;res,
    err=&gt;{
        Promise.reject(err)
    }
)
const get = (url,pramas)=&gt;{
    axiosInstance.request({
        method:&#39;get&#39;,
        url,
        headers:{...}
        params
    })
    .then()
}
const post = (url,data)=&gt;{
    axiosInstance.request({
        method:&#39;post&#39;,
        url,
        data,
        headers:{...}
    })
}
export default {get,post,API}</code></pre>
<h2 id='3-'>3. 反向代理配置</h2>
<p><strong>vue 2.x：在 config/index.js 中配置（待验证）</strong></p>
<pre><code class="lang-javascript">// vue-cli 配置代理的配置参数：
proxyTable：{
    // 代理规则
    &#39;/api&#39;:{
        // 代理的目标服务器地址
        target:&#39;&#39;,
        // https请求需要该设置
        secure:false,
        // 必须设置该项
        changeOrigin:true,
        // 将&#39;/api&#39;替换成&#39;&#39;
        pathRewrite:{&quot;^/api&quot;:&quot;&quot;}
    }
}</code></pre>
<p><strong>vue 3.0 在 vue-cli 生成的项目根目录中创建一个 vue.config.js（与 package.json 同级）</strong></p>
<pre><code class="lang-javascript">// https://cli.vuejs.org/zh/config/#devserver-proxy
module.exports = {
  // 选项...
  // devServer 实际上就是 webpack-dev-server 这个包
  devServer: {
    // proxy 设置代理的配置项
    // 配置文档：https://github.com/chimurai/http-proxy-middleware#proxycontext-config
    proxy: {
      // &#39;/api&#39; 表示 代理规则
      // 在 Vue 组件中使用 axios 发送请求的时候： axios.get(&#39;/api/xxx&#39;)
      // 也就是你的请求地址需要以当前规则（比如：/api）开头，那么，本次请求才会被代理
      // 如果某一个接口不需要被代理，就可以直接： axios.get(&#39;http://localhost:8080/api/xxx&#39;)
      // 这样配置后，最终的得到的接口地址为： http://localhost:8080/api/xxx
      &#39;/api&#39;: {
        // 目标服务器地址，也就是接口服务器的真实地址
        target: &#39;http://localhost:8080/&#39;,
        // 跨域时一般都设置该值 为 true
        changeOrigin: true,
        // 重写接口路由
        pathRewrite: {
          &#39;^/api&#39;: &#39;&#39; // 这样处理后，最终得到的接口路径为： http://localhost:8080/xxx
        }
      },
      // 其他代理~
    &#39;/foo&#39;: {
      target: &#39;&#39;
    }
  }
}</code></pre>
<p><strong>React：</strong></p>
<ol>
  <li>
    <p>安装 yarn add http-proxy-middleware</p>
  </li>
  <li><p>在 src 中创建文件：setupProxy.js</p></li>
</ol>
<pre><code class="lang-javascript" >const proxy = require(&#39;http-proxy-middleware&#39;)
  module.exports = function(app) {
    app.use(
        proxy(&#39;/api&#39;,{
            target:&#39;&#39;,
            changeOrigin:true,
            pathRewrite:{
                &#39;^/api&#39;:&#39;&#39;
            }
        })
    )
}</code></pre>
<h2 id='4-'>4. XMLHttpRequest</h2>
<pre><code class="lang-javascript" >  //创建一个XMLHttpRequest对象
   var xhr = new XMLHttpRequest()
   //设置请求行(post方式)
   xhr.open(&#39;post&#39;, 请求地址)
   //设置请求行(get方式)请求的地址 需要在url后面拼上参数列表
   xhr.open(&#39;get&#39;,请求地址？参数)
   //设置请求头(get方式不需要请求头)
   xhr.setRequestHeader(
           &#39;Content-Type&#39;,
           &#39;application/x-www-form-urlencoded&#39;
   )
   //设置请求体(post方式)
   xhr.send(&#39;username=&#39; + this.value)
   //设置请求体(get方式参数在地址内，所以请求体不需要传参)
   xhr.send(null)
   //获取响应事件
   xhr.onreadystatechange = function () {
           // 响应状态为4并且响应成功200
           if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
           //响应体
              xhr.responseText
           }
   }</code></pre>
<h2 id='5-'>5. 文件下载，后端给的是 blob 类型</h2>
<pre><code class="lang-javascript" >// 请求省略
// 根据请求头的content-type判断是文件还是错误提示
if (res.headers[&quot;content-type&quot;] === &quot;application/octet-stream&quot;) {
  const blob = new Blob([res.data], {
    type: &quot;application/octet-stream&quot;
  });
  // 获取文件名
  const _fileName = res.headers[&quot;content-disposition&quot;].split(&quot;=&quot;)[1];
  // 兼容浏览器的下载
  try {
    if (navigation.msSaveOrOpenBlob) {
      navigation.msSaveBlob(blob, _fileName);
    } else {
      const a = document.createElement(&quot;a&quot;);
      a.href = URL.createObjectURL(blob);
      a.download = decodeURIComponent(_fileName);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
    }
  } catch (error) {
    // 当下载方法不支持时，弹窗提示用户浏览器不支持下载，尝试其他浏览器(vue为例)
    this.$alert(
      `错误信息：your device dose not support files dowloading. Please try again in other browser.`,
      &quot;提示&quot;,
      {
        confirmButtonText: &quot;确定&quot;,
        type: &quot;error&quot;
      }
    );
  }
}
</code></pre>
<h2 id="6-promise">6. 实现一个简单的 promise</h2>
<p>实现思路：需要实现下面代码</p>
<pre><code class="lang-javascript">new myPromise((resolve, reject) =&gt; {
  resolve(10);
})
  .then(res =&gt; {
    console.log(res); //10
    return res * 10;
  })
  .then(res =&gt; {
    console.log(res); //100
  });
new myPromise((resolve, reject) =&gt; {
  reject(&quot;ERROR&quot;);
}).catch(e =&gt; {
  console.log(e); //ERROR
});
</code></pre>
<ol>
<li><code>resolve</code>、<code>reject</code>是立即执行的</li>
<li><code>then</code>里面的方法是根据<code>status</code>判断为暂缓执行的<code>resolve</code>，该函数放进任务序列</li>
<li><code>catch</code>里面的方法也是根据<code>status</code>判断为暂缓执行的<code>reject</code>，放进任务序列</li>
<li><code>class myPromise</code>里面就含有任务状态<code>``status`、任务序列</code>queueResolve<code>、</code>queueReject<code>、保存参数的</code>_val<code>、任务</code>_func<code>`</code></li>
<li><code>status</code>状态为等待<code>PENDING</code>、接受<code>RESOLVE</code>、拒绝<code>REJECTED</code>。默认等待。<code>_val</code>先声明，在<code>resolve</code>、<code>reject</code>中赋值。任务<code>_func</code>接收入参<code>func</code></li>
<li><code>then</code>、<code>catch</code>因为可以链式，所以都要<code>return new myPromise((resolve,reject)=&gt;{})</code>。<code>PENDING</code>状态将任务<code>func</code>以及<code>resolve,reject</code>放到任务序列。执行状态，获取结果<code>const result = func(this._val)</code>，<code>return new myPromise()</code></li>
</ol>
<pre><code class="lang-javascript">class myPromise {
  constructor(func) {
    (this.status = &quot;PENDING&quot;), (this._val = null), (this._func = func);
    (this.queueResolve = []), (this.queueReject = []);
    const myResolve = val =&gt; {
      setTimeout(() =&gt; {
        if (this.status !== &quot;PENDING&quot;) return;
        this.status = &quot;RESOLVE&quot;;
        this._val = val;
        this.queueResolve.forEach(({ func, resolve, reject }) =&gt; {
          resolve(func(val));
        });
      }, 0);
    };
    const myReject = val =&gt; {
      setTimeout(() =&gt; {
        if (this.status !== &quot;PENDING&quot;) return;
        this.status = &quot;REJECTED&quot;;
        this._val = val;
        this.queueReject.forEach(({ func, resolve, reject }) =&gt; {
          reject(func(val));
        });
      }, 0);
    };
    this._func(myResolve, myReject);
  }
  then(func) {
    if (this.status === &quot;RESOLVE&quot;) {
      const result = func(this._val);
      return new myPromise(resolve =&gt; {
        resolve(result);
      });
    }
    if (this.status === &quot;PENDING&quot;) {
      return new myPromise((resolve, reject) =&gt; {
        this.queueResolve.push({ func, resolve, reject });
      });
    }
  }
  catch(func) {
    if (this.status === &quot;REJECTED&quot;) {
      const result = func(this._val);
      return new myPromise((resolve, reject) =&gt; {
        reject(result);
      });
    }
    if (this.status === &quot;PENDING&quot;) {
      return new myPromise((resolve, reject) =&gt; {
        this.queueReject.push({ func, resolve, reject });
      });
    }
  }
}
</code></pre>
<h1 id="math-array-string-">Math，Array，String 的常用方法</h1>
<h2 id="1-math">1. Math</h2>
<p><strong>abs(X)</strong>：返回 X 的绝对值</p>
<p><strong>ceil(X)</strong>：向上取整；floor(X)：向下取整</p>
<p><strong>round(X)</strong>：四舍五入</p>
<p><strong>max(X，Y)</strong>：比较最大值；min(X，Y)：比较最小值</p>
<p><strong>random()</strong>：随机数，返回 0~1 之间的数，一般需要*数值</p>
<h2 id="2-array">2. Array</h2>
<p><strong>arr.concat(x,y,z.....)</strong>：连接两个或多个数组，参数可为元素或者数组，返回一个新的数组，<strong>不改变</strong>原数组</p>
<p><strong>arr.join(x)</strong>：将数组拼成字符串，参数为分隔符</p>
<p><strong>arr.pop()</strong>：删除数组的最后一个元素，返回删除后的数组，<strong>不改变</strong>原数组</p>
<p><strong>arr.shift()</strong>：删除数组的第一个元素，返回第一个元素，<strong>改变</strong>原数组</p>
<p><strong>arr.push(x,y,z......)</strong>：向数组的末尾添加一个或多个元素，返回添加后的数组长度，<strong>改变</strong>原数组</p>
<p><strong>arr.unshift(x,y,z......)</strong>：向数组的开头添加一个或多个元素，返回添加后的数组长度，<strong>改变</strong>原数组</p>
<p><strong>arr.reverse()</strong>：颠倒数组，<strong>改变</strong>原数组</p>
<p><strong>arr.sort(x)</strong>：排序数组，参数为排序的函数，不传会有默认排序按字母顺序，<strong>改变</strong>原数组</p>
<p><strong>arr.slice(start,end)</strong>：从数组中截取元素，</p>
<p>参数：start，必需，从何处开始截取，负数从尾部开始截</p>
<p>​ end，在何处结束，不写，则截取数组结束的全部元素</p>
<p>返回一个由截取下来的元素组成的新数组，<strong>不改变</strong>原数组</p>
<p><strong>arr.splice(index,howmany,item1,....itemx)</strong>：在数组的某个位置添加/删除元素</p>
<p>参数：index，必需，添加/删除元素的位置，负数从尾部开始</p>
<p>​ howmany，必需，删除元素数量，为 0，不删除</p>
<p>​ item1,...itemx，可选，向数组中添加新的元素</p>
<p>返回值：被删除项目的新数组，如果有的话。<strong>改变</strong>原数组</p>
<p><strong>arr.indexOf(x)</strong>：查找某个元素在数组中第一次出现的位置，返回值为下标，为-1 说明不存在</p>
<p><strong>arr.lastIndexOf()</strong>：查找某个元素在数组最后一次出现的位置，返回值为下标，为-1 说明不存在</p>
<h2 id="3-string">3. String</h2>
<p><strong>string.trim()</strong>：删除字符串两边的空格</p>
<p><strong>string.toUpperCase()</strong>：大写 <strong>string.toLowerCase()</strong>：小写</p>
<p><strong>string.slice(start,end)</strong>：提取字符串的某一部分，包含 start，不包含 end</p>
<p>参数：下标，为负数，从尾部开始</p>
<p>返回一个新的字符串为截取部分</p>
<p><strong>string.substring(start,end)</strong>：提取两个下标之间的字符，包含 start，不包含 end</p>
<p>参数：start，必需，非负整数。end，可选，非负整数</p>
<p>返回一个新的字符串</p>
<p><strong>string.substr(start,length)</strong>：截取 start 下标开始指定数目的字符</p>
<p>参数：start，必需，为负数，从尾部开始，length，可选，数值</p>
<p>返回一个新的字符串，从 string 的 start 处开始 length 个长度的字符串</p>
<p><strong>string.split(separator,howmany)</strong>：将字符串分割成数组</p>
<p>参数：separator，必需，字符串或者正则表达式。</p>
<p>​ howmany：可选，返回数组的最大长度</p>
<p>返回一个新的数组</p>
<p><strong>string.replace(regexp/substr,replacement)</strong>：用一些字符替换字符串中另一些字符</p>
<p>参数：regexp/substr，必需，检索的对象，字符串/正则表达式</p>
<p>​ replacement，必需，替换的文本</p>
<p>返回替换后的新的字符串</p>
<h1 id="flex-">flex 布局（真香布局）</h1>
<h2 id="1-display-flex">1. display:flex</h2>
<p>盒子设置了 display：flex 之后，这个盒子就有了主轴和侧轴的概念，子元素默认在主轴开始的位置排列</p>
<h2 id="2-flex-direction">2. flex-direction</h2>
<p>修改主轴的方向</p>
<p>参数：row：默认值，水平向右；row-reverse：水平向左；column：垂直向下；column-reverse：垂直向上</p>
<p><strong>真香布局</strong>：</p>
<ol>
<li>当我们需要竖向排列盒子时，设置成 column。</li>
<li>实现头部底部固定定位，中间盒子展示内容。可以使用 flex-direction:column 代替头部底部的固定定位（曾遇到过 iPhone 在使用 flex 布局与底部固定定位时的 BUG。然后用 flex 布局代替固定定位）</li>
</ol>
<h2 id="3-justify-content">3. justify-content</h2>
<p>设置子元素在主轴上的排列方式</p>
<p>参数：flex-start：默认，在主轴开始的位置排列；flex-end：在主轴结尾的位置排列；center：在中间排列；space-around：盒子均分排布，带左右空隙；space-between：盒子均分排布，左右贴边</p>
<p><strong>真香布局</strong>：space-between space-around 谁用谁知道</p>
<h2 id="4-align-items">4. align-items</h2>
<p>设置侧轴的排列方式（单行）</p>
<p>参数：flex-start：在侧轴顶部的位置排列（贴着顶部）； flex-end：在侧轴底部的位置排列（贴着底部）； center：中间；stretch：子盒子没有高度时默认拉伸（上下）</p>
<p><strong>真香布局</strong>：垂直居中 使用 center</p>
<h2 id="5-flex-wrap">5. flex-wrap</h2>
<p>设置子元素是否换行</p>
<p>参数：nowrap 不换行 wrap 换行</p>
<p><strong>真香布局</strong>：正常都是不换行，但是换行可以实现 n 宫格。子元素给好宽度比</p>
<h2 id="6-align-content">6. align-content</h2>
<p>设置子元素在侧轴的排列方式（多行）</p>
<p>参数：flex-start：默认，在侧轴开始的位置排列；flex-end：在侧轴结尾的位置排列；center：在中间排列；space-around：盒子均分排布，带上下空隙；space-between：盒子均分排布，上下贴边；stretch：拉伸，不设置高度的情况下</p>
<p>用的少</p>
<h2 id="7-flex">7. flex</h2>
<p>子元素设置的，分配在主轴的空间 参数为数字</p>
<h2 id="8-order">8. order</h2>
<p>子元素设置的，排列顺序，默认 0，数值越小，顺序越靠前</p>
<h2 id="9-align-self">9. align-self</h2>
<p>子元素设置的，设置单个子元素在侧轴的排列方式</p>
<p>参数：flex-start：在侧轴顶部的位置排列（贴着顶部）； flex-end：在侧轴底部的位置排列（贴着底部）； center：中间；stretch：子盒子没有高度时默认拉伸（上下）</p>
<h1 id="git">git</h1>
<h2 id="1-">1. 常用指令</h2>
<p><strong>git config --global user.name+作者名</strong></p>
<p><strong>git config --global user.email+邮箱</strong></p>
<p>每台电脑执行一次，设置</p>
<p><strong>git add</strong>：git 管理文件</p>
<p><strong>git commit -m &quot;描述&quot;</strong>：将提交内容生成版本存到库中</p>
<p><strong>git commit --amend</strong>：修改 commit 描述，英文输入法下 i 进入编辑，编辑好后 esc 保存，：q 确定（：wq！强制确定）</p>
<p><strong>git fetch --all</strong></p>
<p><strong>git pull --rebase origin 分支</strong></p>
<p><strong>git push</strong></p>
<p><strong>git status</strong>：查看当前项目状态</p>
<h2 id="2-">2. 回滚版本</h2>
<p><strong>git log</strong>：查看以往提交版本信息</p>
<p><strong>git reflog</strong>：查看所有日志</p>
<p><strong>git reset --hard 版本号</strong>：回滚到指定版本</p>
<h2 id="3-git-diff-">3. git 查看 diff 不同</h2>
<p><strong>git diff</strong>：工作区与暂存区不同</p>
<p><strong>git diff -cache</strong>：暂存区与库存区的不同</p>
<p><strong>git diff HEAD</strong>：工作区与库存区的不同</p>
<p><strong>git diff 版本号 1 版本号 2</strong>：两个版本之间的不同</p>
<h2 id="4-git-">4. git 分支</h2>
<p><strong>git branch</strong>：查看分支信息</p>
<p><strong>git checkout 分支名</strong>：切换分支</p>
<p><strong>git checkout -b 分支名</strong>：新建并切换到新分支</p>
<p><strong>git merge 分支 B</strong>：在分支 A 上把分支 B 合并过来</p>
<p><strong>git branch -d 分支名</strong>：删除分支</p>
<h2 id="5-git-">5. git 与远程仓库</h2>
<p><strong>git clone</strong>：克隆代码</p>
<p><strong>git remote add 别名 仓库地址</strong>：用别名替代仓库地址</p>
<p><strong>git remote</strong>：查看所有别名</p>
<p><strong>git remote get-url 别名</strong>：获取别名的仓库地址</p>
<p><strong>git remote set-url 别名 仓库地址</strong>：仓库地址设置别名</p>
<h2 id="6-git-">6. git 忽略文件</h2>
<p>开发项目的时候我们可能有些文件、文件夹不需要 git 管理。在 git add 之前，新建一个.gitignore 文件，在.gitignore 文件里写不需要 git 管理的文件，文件夹名</p>
<h1 id="webpack">Webpack</h1>
<h2 id="1-">1. 介绍</h2>
<p>webpack 模块化打包工具</p>
<p>安装：<code>npm i webpack webpack-cli -D</code></p>
<p>在<code>package.json</code>中添加<code>scripts</code>，以以下两种方式</p>
<ol>
<li><pre><code class="lang-json">&quot;scripts&quot;:{
    &quot;build&quot;:&quot;webpack index.js -o ./dist/bundle.js&quot;
}
</code></pre>
</li>
<li><pre><code class="lang-json">&quot;scripts&quot;:{
    &quot;build&quot;:&quot;webpack&quot;
}
// 还需要在根目录下创建webpack.config.js
</code></pre>
</li>
</ol>
<h2 id="2-webpack-">2. webpack 常规配置</h2>
<pre><code class="lang-javascript">module.exports = {
  mode: &quot;development&quot;,
  // entry入口文件
  entry: path.join(_dirname, &quot;./src/main.js&quot;),
  // output输出文件
  output: {
    path: path.join(_dirname, &quot;dist&quot;),
    filename: &quot;handler.js&quot;
  },
  // module规则
  module: {
    rules: []
  },
  // plugins插件
  plugins: []
};
</code></pre>
<h2 id="3-loader">3. 不同文件配置 loader</h2>
<p>webpack 只认识 js，默认也只对 js 进行打包，对于 css、图片、字体图标、vue 文件都不认识，所以需要配置对应的 loader（需要安装），在 module 的 rules。具体<a href="https://www.webpackjs.com/loaders/">配置</a></p>
<pre><code class="lang-javascript">rules: [
  {
    test: /\.less$/,
    use: [
      {
        // creates style nodes from JS string
        loader: &quot;style-loader&quot;
      },
      {
        // translates css into commonJS
        loader: &quot;css-loader&quot;
      },
      {
        // compiles Less to css
        loader: &quot;less-loader&quot;
      }
    ]
  },
  {
    test: /\.vue$/,
    loader: &quot;vue-loader&quot;
  },
  {
    // 用来匹配文件名称的
    test: /\.js$/,
    use: {
      loader: &quot;babel-loader&quot;,
      options: {
        presets: [&quot;@babel/preset-env&quot;]
      }
    }
  }
];
</code></pre>
<h2 id="4-plugins-">4. plugins 插件</h2>
<ol>
<li><p>VueLoaderPlugin：vue 打包必须的插件</p>
<pre><code class="lang-js">const VueLoaderPlugin = require(&quot;vue-loader/lib/plugin&quot;);
</code></pre>
</li>
<li><p>webpack 打包时 dist 文件中没有 HTML 文件：此时需要使用<code>html-webpack-plugin</code>可以自动生成 html</p>
<pre><code class="lang-js">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
</code></pre>
</li>
<li><p>打包时需要自动删除之前的 dist 文件夹新建：使用<code>clean-webpack-plugin</code></p>
<pre><code class="lang-js">const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);
</code></pre>
</li>
</ol>
<pre><code class="lang-javascript">plugins: [
  // 确保引入了插件
  new CleanWebpackPlugin(),
  new HtmlWebpackPlugin({
    template: path.join(_dirname, &quot;./src/index.html&quot;)
  }),
  new VueLoaderPlugin()
];
</code></pre>
<h2 id="5-webpack-dev-server">5. webpack-dev-server</h2>
<p>安装：<code>npm install --save-dev webpack-dev-server</code></p>
<p>作用：自动启动 http 服务，自动打开浏览器，自动监听文件的变化，每次修改代码，都会重新打包（在临时文件夹）所以还需要 build 打包</p>
<pre><code class="lang-javascript">// 与plugins同级
devServer: {
    // 打包输出的文件夹名
    contentBase: &#39;./dist&#39;,
    // 运行的端口
    port: 9999,
    // 是否自动打开浏览器
    open: true
}
</code></pre>
<h1 id="-">前端面试题</h1>
<h2 id="-1-">*1. 前端优化的方案有哪些</h2>
<p>可以百度雅虎 14 条性能优化原则，下面回答仅仅只是本人能理解，会使用的</p>
<ol>
<li>减少 HTTP 请求次数：CSS Sprites,JS、CSS 源码压缩，图片大小控制适合；CDN 托管，data 缓存，图片服务器</li>
<li>前端模板 JS+数据，减少由 HTML 标签导致的带宽浪费，前端用变量保存 ajax 请求结果，每次操作本地变量，不同请求，减少请求次数</li>
<li>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能</li>
<li>当需要设置的样式很多时，设置 className 而不是直接操作 style</li>
<li>少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作</li>
<li>避免使用 CSS Expression（CSS 表达式）</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li>
<li>避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+CSS 布局慢</li>
</ol>
<h2 id="-2-css-">*2. CSS 选择器（符）有哪些，优先级算法如何计算</h2>
<p>通配符选择器<code>*</code>，类名选择器<code>.</code>，id 选择器<code>#</code>，标签选择器、后代选择器 <code>div p</code>，子代选择器<code>div&gt;p</code>，交集选择器<code>div.p</code>，并集选择器<code>div,p</code>，伪类选择器<code>:</code>，属性选择器<code>[]</code>，伪元素选择器<code>::</code>，结构伪类选择器<code>:first-child</code></p>
<p>优先级：<code>!important&gt;[id&gt;class&gt;tag]</code></p>
<h2 id="-3-">*3. 盒子模型</h2>
<p>标准盒子模型：margin、border、padding、content</p>
<p>IE 盒子模型：margin、content（border、padding）</p>
<h2 id="-4-url-">*4. 尽可能完整的描述从输入 URL 到整个网页加载完毕及显示在屏幕上的整个流程</h2>
<ol>
<li>输入 URL</li>
<li>浏览器获取 URL，通过 DNS 解析获得网址对应的 IP 地址。首先先去各个缓存当中看看有没有 DNS 缓存，如果有则直接显示，不需要重新发送 HTTP 请求</li>
<li>如果没有浏览器就会向服务器发送一个 HTTP 请求</li>
<li>服务器处理请求并返回一个 HTTP 响应报文</li>
<li>浏览器收到响应后，进行客户端渲染，生成 DOM 树，CSS 树，执行 JS 交互</li>
<li>浏览器绘制页面</li>
</ol>
<h2 id="-5-cookies-sessionstorage-localstroage-">*5. 描述 cookies，sessionStorage 和 localStroage 区别</h2>
<p><strong>cookies：</strong>周期时间前后端都可以设置，大小不超过 4k，cookies 的数据会自动传递到服务器，服务器也可以写 cookies 到客户端</p>
<p><strong>sessionStorage：</strong>页面关闭就会清理，大小达到 5M 或更大，不会自动把数据发给服务端，仅在本地保存</p>
<p><strong>localStorage：</strong>存储持久数据，除非主动删除数据否则数据一直存储，大小也达到 5M 或更大，也不会自动把数据发给服务器，仅在本地保存</p>
<h2 id="-6-">*6. 冒泡排序</h2>
<pre><code class="lang-javascript">// 降序
function sort(arr) {
  for (var i = 0; i &lt; arr.length - 1; i++) {
    var flag = true;
    for (var j = 0; j &lt; arr.length - 1 - i; j++) {
      if (arr[j] &lt; arr[j + 1]) {
        var temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        flag = false;
      }
    }
    if (flag === true) {
      break;
    }
  }
  return arr;
}
</code></pre>
<h2 id="-7-">*7. 如何解决跨域问题</h2>
<p><strong>JSONP：</strong>使用 script 标签向后端请求数据，只适合 get 请求</p>
<p><strong>CORS：</strong>让服务端设置<code>Response Header</code>响应头中的<code>Access-Control-Allow-Origin</code>为对应的域名 ，这样浏览器就不会报跨域错误，但出于安全性考虑尽量不要使用<code>*</code></p>
<p><strong>反向代理：</strong>搭建一个自己的服务器，让我的服务器请求数据，拿到数据之后再返回给自己</p>
<p><strong>实际开发中：</strong></p>
<ol>
<li>只有本地调用测试环境可能会跨域，我们只需要设置浏览器就可以解决跨域问题</li>
</ol>
<pre><code class="lang-javascript">// 在浏览器快捷方式的目标
&quot;C:\Program Files (x86)\chrome.exe&quot;
// 后面加上
--disable-web-security --user-data-dir=D:\MyChromeDevUserData
</code></pre>
<ol start="2">
<li>进行 webpack 的反向代理配置</li>
</ol>
<p><strong>实际生产中：</strong></p>
<p>nginx 配置</p>
<h2 id="-8-bfc">*8. 什么是 BFC</h2>
<p>块级格式化上下文，具有 BFC 特性的元素可以看做是隔离了的单独容器，容器里面的元素不会在布局上影响到外面的元素，也不会受到外面元素的影响。</p>
<p>只要元素满足下面任一条件即可触发 BFC 特性</p>
<ul>
<li>body 根元素</li>
<li>浮动元素</li>
<li>position 为 absolute 或 fixed</li>
<li>display 为 inline-block，table-cell，table-caption，flex，inline-flex</li>
<li>overflow 不为 visible</li>
</ul>
<h2 id="-9-css-iphone-ipad-">*9. CSS 去掉 iPhone，iPad 默认按钮样式</h2>
<pre><code class="lang-css">input[type=&quot;button&quot;],
input[type=&quot;submit&quot;],
input[type=&quot;reset&quot;] {
  -webkit-appearance: none;
}
textarea {
  -webkit-appearance: none;
}
</code></pre>
<h2 id="-10-javascript-">*10. javascript 是一门怎么样的语言，它有哪些特点</h2>
<p>JavaScript 是一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，广泛用于客户端的脚步语言，最早是在 HTML 网页上使用，用来给 HTML 网页增加动态功能。</p>
<p>JavaScript 兼容于 ECMA 标准，因此也称为 ECMAScript。</p>
<p>基本特点</p>
<ol>
<li>是一种解释性脚本语言（代码不进行预编译）</li>
<li>主要用来向 HTML 页面添加交互行为</li>
<li>可以直接嵌入 HTML 页面，但写成单独的 js 文件有利于结构和行为的分离</li>
<li>跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行</li>
</ol>
<h2 id="-11-new-">*11. 构造函数中 new 做了四件事</h2>
<ol>
<li>创建一个新的对象</li>
<li>把 this 指向新对象</li>
<li>执行构造函数</li>
<li>返回新对象</li>
</ol>
<h2 id="-12-">*12. 原型，原型链是什么，原型链的应用</h2>
<p>每个函数创建的时候都会有一个自带的属性，这个属性指向一个对象，这个对象就是原型。</p>
<p>每个构造函数所创建出来的实例都可以调用这个原型上的属性和方法。</p>
<p>原型本身也是一个对象，这个对象就是 Object 的实例，所以原型也可以调用到 Object 的原型，这样就组成一个链式结构，这个就是原型链</p>
<p>原型链是实现继承的主要方法</p>
<h2 id="-13-">*13. 什么是内存泄漏，哪些操作会造成内存泄漏</h2>
<p>内存泄漏是指一块被分配的内存既不被使用，也不被回收，直到浏览器进程结束。</p>
<p>造成内存泄漏的操作：</p>
<ol>
<li>全局变量引用的内存泄漏</li>
<li>闭包引起的内存泄漏</li>
<li>DOM 清空或者删除时，事件未清除导致的内存泄漏</li>
<li>被遗忘的计时器或回调函数</li>
</ol>
<h2 id="-14-clone-5-">*14. 实现一个函数 clone，可以对 5 种主要的数据类型进行值复制</h2>
<pre><code class="lang-javascript">function clone(obj) {
  let o;
  switch (typeof obj) {
    case &quot;undefined&quot;:
      break;
    case &quot;number&quot;:
      o = +obj;
      break;
    case &quot;string&quot;:
      o = obj + &quot;&quot;;
      break;
    case &quot;boolean&quot;:
      o = !!obj;
      break;
    case &quot;object&quot;:
      if (obj === null) {
        o = null;
      } else {
        o = Array.isArray(obj) ? [] : {};
        for (let key in obj) {
          o[key] = typeof obj[key] === &quot;object&quot; ? clone(obj[key]) : obj[key];
        }
      }
      break;
  }
  return o;
}
</code></pre>
<h2 id="-15-http-">*15. HTTP 状态码定义</h2>
<ul>
<li><p>1 开头：消息</p>
</li>
<li><p>2 开头：成功
200-请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态</p>
</li>
<li><p>3 开头：重定向</p>
</li>
<li><p>4 开头：请求错误
400-1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。</p>
<p>401-当前请求需要用户验证</p>
<p>403-服务器已经理解请求，但是拒绝执行它。</p>
<p>404-请求失败，请求所希望得到的资源未被在服务器上发现。</p>
</li>
<li><p>5 开头：服务器错误
500-服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。
详见<a href="https://www.cnblogs.com/liaoshiyong/p/3150839.html">https://www.cnblogs.com/liaoshiyong/p/3150839.html</a></p>
</li>
</ul>
<h1 id="node-js">Node.js</h1>
<h2 id="1-node-nvm-">1. node 版本管理器（NVM）</h2>
<p>nvm（Linux、Unix、OS X）</p>
<p>常用命令：</p>
<ul>
<li>nvm install node ：安装最新 node.js</li>
<li>nvm use node：使用指定版本 node.js</li>
</ul>
<p>nvm-windows</p>
<p>常用命令：</p>
<ul>
<li>nvm version：查看 nvm 是否安装成功</li>
<li>nvm install latest：下载最新版本 node.js</li>
<li>nvm install 版本号：下载指定版本 node.js</li>
<li>nvm uninstall 版本号：卸载指定版本 node.js</li>
<li>nvm list：查看电脑上安装的所有 node.js 版本</li>
<li>nvm use 版本号：使用指定版本 node.js</li>
</ul>
<h2 id="2-">2. 文件读写</h2>
<p>fs 模块 <code>const fs = require(&#39;fs&#39;)</code></p>
<ul>
<li><code>fs.writeFile(file,data[,options],callback)</code></li>
<li><code>fs.readFile(filre[,options],callback)</code></li>
</ul>
<p>file 是文件路径</p>
<p>options 可以为文件编码，具体看文档</p>
<p>文件路径方式：</p>
<ol>
<li><p>相对路径</p>
</li>
<li><p><code>__dirname</code>：当前文件路径</p>
<p><code>__filename</code></p>
<p>缺点：window 与 Linux、苹果操作系统，拼接路径的&#39;\&#39;不同，无法统一</p>
</li>
<li><p>path 模块：</p>
<pre><code class="lang-js">const path = require(&quot;path&quot;);
let filename = path.join([...paths]);
</code></pre>
</li>
</ol>
<h2 id="3-">3. 创建目录</h2>
<p>创建一个文件夹</p>
<pre><code class="lang-js">const fs = require(&quot;fs&quot;);
fs.mkdir(&quot;./test-mkdir&quot;, callback);
</code></pre>
<h2 id="4-http-">4. http 模块</h2>
<pre><code class="lang-js">const http = require(&quot;http&quot;);
const server = http.createServer();
// 监听用户请求事件
// request对象包含用户请求报文，可以获取所有用户提交过来的数据
// response对象向用户响应一些数据
server.on(&quot;request&quot;, function (request, response) {
  //request.url可以获取到用户不同请求
  console.log(request.url);
  // 解决乱码，响应报文头，告诉浏览器使用对应的编码来解析网页
  response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf8&quot;);
  response.write(&quot;Hellp world！！&quot;);
  // 必须结束响应，否则浏览器一直等待响应
  response.end();
});
// 启动服务
server.listen(8080, function () {
  // 启动服务时的回调
});
</code></pre>
<h2 id="5-html-request">5. 读取 html 页面响应不同 request</h2>
<pre><code class="lang-js">const http = require(&#39;http&#39;)
const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)

http.createServer(function(req,res){
    if(req.url === &#39;/&#39;|| req.url === &#39;/index&#39;){
        fs.readFile(path.join(__dirname,&#39;htmls&#39;,&#39;index.html&#39;),function(err,data){
            if(err){
                throw err
            }
            res.end(data)
        })
    }else if(req.url === &#39;login&#39;){
        ...
    }else{
        ...
    }
}).linsten(8080,function(){})

</code></pre>
<p>静态资源，图片，css 也需要这样判断</p>
<h2 id="6-">6. 更简单的静态资源处理方法</h2>
<p>根据<code>req.url</code>拼接文件路径，来访问静态资源</p>
<p><code>mine</code>模块根据不同的资源返回对应的 content-type</p>
<pre><code class="lang-js">npm i mine
</code></pre>
<pre><code class="lang-js">// 静态资源存放在public文件夹内
// public文件夹完整路径
let publicDir = path.join(__dirname, &quot;public&quot;);
// 静态资源与public文件夹路径拼接出完整的文件路径
let filename = path.join(publicDir, req.url);
// 读取文件路径，读取到返回文件，读取错误返回404
fs.readFile(filename, function (err, data) {
  if (err) {
    res.end(&quot;404&quot;);
  } else {
    // 引入mine模块
    res.setHeader(&quot;Content-Type&quot;, mine.getType(filename));
    res.end(data);
  }
});
</code></pre>
<p>url 就是一个标识，不一定是请求的文件（比如 index.do 也可以返回 index.html）</p>
<h2 id="7-request-response-api">7. request，response 常用 API</h2>
<p>文档中 request 对象是 http.IncomingMessage，response 对象是 http.ServerResponse</p>
<p>request 对象常用 API</p>
<ul>
<li><code>request.headers</code>：获取所有请求报文头（输出对象）</li>
<li><code>request.rawHeaders</code>：获取所有请求报文头（输出数组，值为字符串）</li>
<li><code>request.httpVersion</code>：请求客户端 http 使用版本</li>
<li><code>request.method</code>：客户端请求方法</li>
<li><code>request.url</code></li>
</ul>
<p>response 对象常用 API</p>
<ul>
<li><p><code>response.write()</code></p>
</li>
<li><p><code>response.end()</code>：每次请求都必须调用。通知服务器，所有响应头和响应主体都已经被发送</p>
</li>
<li><p><code>response.setHeader()</code>：设置报文响应头</p>
</li>
<li><p><code>response.statusCode</code>：设置 http 响应状态码</p>
</li>
<li><p><code>response.statusMessage</code>：设置 http 响应状态码对应的消息</p>
</li>
<li><p><code>response.writeHead()</code>：写入 http 报文响应头</p>
<pre><code class="lang-js">res.writeHead(404, &quot;Not Found&quot;, {
  &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;
});
</code></pre>
</li>
</ul>
<h2 id="8-">8. 第一次读取文件的处理</h2>
<pre><code class="lang-js">fs.readFile(&quot;data.json&quot;, &quot;utf8&quot;, function (err, data) {
  // 第一次访问文件，文件不存在，会报错
  // 但这种错误并不是网站出错，不需要抛出异常
  if (err &amp;&amp; err.code !== &quot;ENOENT&quot;) {
    throw err;
  }
  let list = JSON.parse(data || &quot;[]&quot;);
});
</code></pre>
<h2 id="9-post-">9. POST 提交数据时的处理</h2>
<p>post 提交数据，会分多次进行提交，每次提交一部分数据。所以需要监听 request 对象的 data 事件，接收数据。监听 request 的 end 事件被触发，说明所有数据都已经提交到服务器</p>
<pre><code class="lang-js">// 引入将post请求数据对象转成JSON对象
const querystring = require(&#39;quertstring&#39;)

......
let array =[]
req.on(&#39;data&#39;,function(chunk){
    array.push(chunk)
})
req.on(&#39;end&#39;,function(err,data){
    let postBody = Buffer.concat(array)
    postBody = querystring.parse(postBody.toString(&#39;utf8&#39;))
   ......
})
......
</code></pre>
<h2 id="10-">10. 服务器端模板引擎渲染</h2>
<h3 id="1-underscore-">1. underscore 模块</h3>
<pre><code class="lang-js">npm i underscore

let _ = require(&#39;underscore&#39;)
</code></pre>
<ul>
<li><p>zip/unzip：</p>
<pre><code class="lang-js">let temp = _.zip([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]);
// temp [{&#39;a&#39;,&#39;1&#39;},{&#39;b&#39;,&#39;2&#39;},{&#39;c&#39;,&#39;3&#39;}]
</code></pre>
</li>
<li><p>template：模板</p>
<pre><code class="lang-js">let temhtml = &quot;&lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt;&quot;;
let fn = _.template(temhtml);
let html = fn({ name: &quot;张三&quot; });
// html &lt;h2&gt;张三&lt;/h2&gt;
</code></pre>
</li>
</ul>
<p>实际应用</p>
<pre><code class="lang-js">fs.readFile(&#39;data.json&#39;,&#39;utf8&#39;,function(err,data){
    ...
    let list = JSON.pares(data||&#39;[]&#39;)
    // 封装了render方法
    res.render(&#39;./index.html&#39;,{list})
})
// render方法
res.render = function (html,tempdata){
    fs.readFile(html,function(err,data){
        if(tempdata){
            let fn = _.template(data.toString(&#39;utf8&#39;))
            data = fn(tempdata)
        }
        res.end(data)
    })
}
</code></pre>
<h1 id="-">微信小程序</h1>
<h2 id="1-appid">1. 注册与获取 APPID</h2>
<p>开发-开发设置 获取 AppId</p>
<h2 id="2-">2. 数据绑定</h2>
<pre><code class="lang-js">// js文件
Page({
    data:{
        msg:&#39;数据&#39;
    }
})
// wxml文件
&lt;text&gt;{{msg}}&lt;/text&gt;
</code></pre>
<ol>
<li>小程序中插值表达式 可以用在属性中</li>
<li>小程序中插值表达式不支持方法调用</li>
<li>小程序中数据绑定是单向的</li>
</ol>
<p>无法直接修改 data 中的数据，来将数据的变化显示在页面中</p>
<p>使用 this.setData({})修改数据</p>
<pre><code class="lang-js">// 事件中
this.setData({
    msg:&#39;修改后的数据&#39;
})
// input
bindInput事件，使用e获取input的value值
</code></pre>
<h2 id="3-">3. 事件绑定</h2>
<p>小程序中有自己独立提供的一套事件绑定机制</p>
<p>两种事件绑定方式：</p>
<ol>
<li>bind 冒泡事件</li>
<li>catch 非冒泡事件</li>
</ol>
<pre><code class="lang-js">// js文件
Page({
    data:{},
    handlerClick(){

    }
})
// wxml文件
&lt;button bindtap=&#39;handlerClick&#39;&gt;冒泡点击&lt;/button&gt;
&lt;button catchtap=&#39;handlerClick&#39;&gt;非冒泡点击&lt;/button&gt;
</code></pre>
<p>给事件传递参数：通过自定义属性传递，事件里通过事件对象获取</p>
<pre><code class="lang-html">&lt;button bindtap=&quot;handlerClick&quot; data-id=&quot;666&quot;&gt;冒泡点击&lt;/button&gt;
</code></pre>
<p>事件内使用参数通过 e.target.dataset 解构出参数</p>
<pre><code class="lang-js">Page({
  handlerClick(e) {
    const { id } = e.target.dataset;
  }
});
</code></pre>
<h2 id="4-">4. 条件渲染</h2>
<ol>
<li><p>条件渲染 wx:if</p>
<p>wx:if=&quot;数据&quot; 数据为 true 展示元素，否则隐藏。隐藏元素时，直接将这个结构删除</p>
<p>wx:elif 相当于 else if</p>
<p>wx:else 相当于 else</p>
</li>
<li><p>条件渲染 hidden</p>
<p>给标签 hidden 属 性，属性值为 true 隐藏，false 显示。</p>
</li>
<li><p>同时控制多个元素展示和隐藏</p>
<p>使用 block 组件，类似于幽灵节点，不会生成标签在 wxml 结构中</p>
</li>
</ol>
<pre><code class="lang-html">&lt;block wx:if=&quot;{{isshow}}&quot;&gt;
  &lt;button&gt;&lt;/button&gt;
  &lt;button&gt;&lt;/button&gt;
  &lt;button&gt;&lt;/button&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/block&gt;
</code></pre>
<h2 id="5-">5. 列表渲染</h2>
<p>wx:for=&quot;{{列表数据}}&quot;</p>
<p>使用时，应该提供 wx:key，值为唯一属性名称</p>
<pre><code class="lang-html">&lt;view wx:for=&quot;{{todos}}&quot; wx:key=&quot;id&quot;&gt;{{index}}--&gt;{{item.name}}&lt;/view&gt;
</code></pre>
<p>修改默认的 index 和 item</p>
<pre><code class="lang-html">&lt;view wx:for=&quot;{{todos}}&quot; wx:key=&quot;id&quot; wx:for-item=&quot;it&quot; wx:for-index=&quot;i&quot;&gt;
  {{i}}--&gt;{{it.name}}
&lt;/view&gt;
</code></pre>
<p>如果列表数据为纯字符串或者数值的数组，遍历时，可以使用*this 作为 key 值。item 作为展示的数据</p>
<pre><code class="lang-html">// todos [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;] &lt;text wx:for=&quot;{{todos}}&quot; wx:key=&quot;*this&quot;&gt;{{item}}&lt;/text&gt;
</code></pre>
<h2 id="6-wxss">6. WXSS</h2>
<p>与 css 差不多，但做了一些扩展</p>
<ol>
<li><p>尺寸单位</p>
<p>rpx ：自适应的尺寸单位，屏幕宽度固定为 750rpx</p>
<p>毛刺问题：50%计算与写死数值，会有一像素差</p>
</li>
<li><p>样式导入</p>
<p>@import 相对路径</p>
</li>
</ol>
<h2 id="7-">7. 发起请求</h2>
<pre><code class="lang-js">wx.request({
  url: &quot;&quot;,
  data: {}, // 请求参数，string，object，array
  header: {}, //设置请求头，不能设置Referer
  method: &quot;&quot;, // 请求方式 GET POST 大写
  success(res) {}, // 成功的回调
  fail: () =&gt; {}, // 失败的回调(箭头函数形式解决this指向问题)
  complete() {} // 请求完成时执行的回调
});
</code></pre>
<p>为了安全性考虑，小程序只允许请求自己网站的接口数据</p>
<p>如何解决接口无法访问的问题？</p>
<ol>
<li>可以在<a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a> 开发-开发设置-服务器域名 设置服务器信息。但每个月有修改限制次数。还需要重新登录微信开发者工具</li>
<li>直接在开发者工具中，在右上角详情-本地配置，勾选：不效验非合法域名（仅限临时开发，上线时仍需配置合法域名）</li>
</ol>
<p><strong>注意请求中 this 指向问题</strong></p>
<h2 id="8-">8. 生命周期钩子函数</h2>
<p>onLoad：进入页面就会执行，此时可以发送请求获取数据。参数 options 可以拿到 url 里的参数 onLoad:function(options){}</p>
<ol>
<li>onLoad 与 onShow</li>
</ol>
<p>onLoad 只有第一次进入页面的时候才会执行，onShow 每次进入页面都会执行</p>
<p>tabBar 页面从来都没有关闭，所以再次进入 tabBar 页面的时候，不会触发 onLoad</p>
<ol start="2">
<li>onHide</li>
</ol>
<p>页面隐藏或切入后台时调用</p>
<h2 id="9-">9. 项目初始化</h2>
<p>项目开始先配置 app.json</p>
<pre><code class="lang-js">// app.json
{
  &quot;pages&quot;:[
    &quot;pages/index/index&quot;,
    &quot;pages/message/message&quot;,
    &quot;pages/profile/profile&quot;
  ],
  &quot;window&quot;:{
      // 顶部背景色
    &quot;navigationBarBackgroundColor&quot;: &quot;#daa520&quot;,
    // 顶部标题
    &quot;navigationBarTitleText&quot;: &quot;本地生活&quot;,
  },
  &quot;tabBar&quot;: {
    &quot;list&quot;: [
    // 只有list里面配置的页面，才会在有tabBar的页面显示
      {
          &quot;pagePath&quot;: &quot;pages/index/index&quot;,
          &quot;text&quot;: &quot;首页&quot;,
          &quot;iconPath&quot;: &quot;/assets/tabs/home.png&quot;,
          &quot;selectedIconPath&quot;: &quot;/assets/tabs/home-active.png&quot;
      },
      {
          &quot;pagePath&quot;: &quot;pages/message/message&quot;,
          &quot;text&quot;: &quot;消息&quot;,
          &quot;iconPath&quot;: &quot;/assets/tabs/message.png&quot;,
          &quot;selectedIconPath&quot;: &quot;/assets/tabs/message-active.png&quot;
      },
      {
          &quot;pagePath&quot;: &quot;pages/profile/profile&quot;,
          &quot;text&quot;: &quot;我的&quot;,
          &quot;iconPath&quot;: &quot;/assets/tabs/profile.png&quot;,
          &quot;selectedIconPath&quot;: &quot;/assets/tabs/profile-active.png&quot;
      }
    ]
  },
}
</code></pre>
<h2 id="10-">10. 自定义编译</h2>
<p>通过自定义编译修改启动页面，可以使每次编译后打开的页面不再是首页。</p>
<h2 id="11-">11. 页面事件函数</h2>
<p>onReachBottom：页面上拉触底事件的处理函数</p>
<p>生命周期钩子函数及页面事件函数见文档 框架-框架接口-页面-Page</p>
<h2 id="12-wxs-">12. WXS 模块</h2>
<p>在 wxml 中有些渲染数据需要修改后使用，但插值表达式不支持函数调用。于是我们可以在 wxml 文件中添加 &lt;wxs&gt;标签，或者使用.wxs 文件。来引入函数，修改数据。通过 module.exports 实现</p>
<p><strong>wxs 模块不支持 ES6 语法</strong></p>
<pre><code class="lang-vue">// 数据date:2020.01.09变成2020-01-09 // wxml文件
&lt;text&gt;{{ tools.replaceDate(date) }}&lt;/text&gt;
&lt;wxs module=&quot;tools&quot;&gt;
    var replaceDate = function(date){
        return date.replace(&#39;.&#39;,&#39;-&#39;)
    }
    module.exports = {
        replaceDate:replaceDate
    }
&lt;/wxs&gt;
// 或者 // wxs文件 var replaceDate = function(date){ return
date.replace(&#39;.&#39;,&#39;-&#39;) } module.exports = { replaceDate:replaceDate } // wxml文件
&lt;wxs src=&quot;../../tools.wxs&quot; module=&quot;tools&quot; /&gt;
&lt;text&gt;{{ tools.replaceDate(date) }}&lt;/text&gt;
</code></pre>
<p>wxs 文件要引入其他 wxs 文件模块，使用 require 函数，必须相对路径</p>
<h2 id="13-weui">13. WeUI</h2>
<p>给微信网页版及小程序提供的 UI 组件库</p>
<p>小程序官网-扩展功能-WeUI 组件库 <strong>具体的查看文档</strong></p>
<h2 id="14-wepy">14. WePY</h2>
<p>小程序组件开发框架，还有类似的美团 mpvue</p>
<ul>
<li><a href="https://wepyjs.github.io/wepy-docs/">wepy 开发文档</a></li>
</ul>
<h3 id="1-">1. 开始项目</h3>
<ul>
<li><p>1 全局安装 cli：</p>
<p>2.x：<code>npm install @wepy/cli -g</code></p>
<p>1.x：<code>npm i -g wepy-cli</code></p>
<p><code>wepy --version</code>查看版本信息</p>
<p>全局安装 CLI 会覆盖老版本的 CLI 工具，新版本的 CLI 无法编译老版本的代码。因此，如果需要同时维护 WePY 1.7.x 和 WePY 2.0.x 的开发者，应当考虑在当前项目安装 CLI，而非全局安装。可以直接使用 1.7.x 的 CLI 去初始化 2.0.x 的项目，如下：<code>$ wepy init standard#2.0.x myproj</code>
</p></li>
<li><p>2 通过脚手架初始化项目：<code>wepy init empty my-project</code> 这样是一个空模板</p>
<pre><code>初始化项目时报错：
wepy-cli Failed to download repo empty: getaddrinfo ENOENT raw.githubsercontent.com raw.githubsercontent.com:443
原因：raw.githubsercontent.com无法访问
解决办法：修改Hosts临时解决GitHub的raw.githubusercontent.com无法链接
1.通过IPAddress.com首页,输入raw.githubusercontent.com查询到真实IP地址
2.C:\Windows\System32\drivers\etc
hosts文件
添加 以下内容并保存即可恢复
查询到的IP地址  raw.githubusercontent.com
</code></pre><pre><code>wepy2.x发送请求报错，未找到解决办法，故放弃2.x使用
</code></pre></li>
<li><p>3 下载依赖项 <code>npm i</code></p>
</li>
<li><p>4 启动项目，并开启实时编译 <code>wepybuild--watch</code>或<code>npm run dev</code></p>
</li>
<li><p>5 在微信开发者工具中 打开<code>dist</code>目录</p>
</li>
<li><p>6 在微信开发者工具中配置：</p>
<ul>
<li>关闭：ES6 转 ES5</li>
<li>关闭：上传代码时样式自动补全</li>
<li>关闭：代码压缩上传</li>
<li>开启：不效验合法域名</li>
</ul>
</li>
</ul>
<h3 id="2-vscode-">2. VSCode 中一些设置</h3>
<p><strong>1. wpy 文件语法高亮</strong></p>
<ul>
<li>安装 vetur 插件</li>
<li>打开任意<code>.wpy</code>文件</li>
<li>右下角选择语言模式，默认为纯文本</li>
<li>在弹出的窗口中选择<code>.wpy的配置文件关联。。。</code></li>
<li><p>选择<code>Vue</code></p>
<p><strong>2. 不效验 wepy 文件</strong></p>
</li>
</ul>
<p>打开的代码标签下面会有红色波浪线</p>
<ul>
<li><p>在 VSCode 设置，搜索 vetur-Validation：Script、Validation：Style、Validation：Template 都不勾选</p>
<p>1.X 的<code>wepy-cli</code>创建的项目里面 template 标签内不兼容小程序标签，添加属性<code>lang=&quot;wxml&quot;</code>即可</p>
<p>2.X 的<code>wepy-cli</code>继承了 WXML 的基本模板语法，并支持大部分 Vue 模板语法。同时，WePY 允许使用大部分 HTML 模板标签，经编译器编译后，会将模板标签转换成标准的 WXML 模板语法。</p>
</li>
</ul>
<h3 id="3-1-7-">3. 1.7 版本使用</h3>
<ol>
<li><p>wepy 的请求与 wx 一样，wepy.request</p>
</li>
<li><p>wepy 支持 promise 和 async await</p>
<p><a href="https://github.com/Tencent/wepy/wiki/wepy%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Promise">文档</a></p>
<ul>
<li><p>安装 polyfill</p>
<pre><code class="lang-js">npm install wepy-async-function --save
</code></pre>
</li>
<li><p>在 app.wpy 引入 polyfill</p>
<pre><code class="lang-js">import &quot;wepy-async-function&quot;;
</code></pre>
</li>
<li><p>在 app.wpy 中使用</p>
<pre><code class="lang-js">export default class extends wepy.app {
  constructor() {
    super();
    this.use(&quot;promisify&quot;);
  }
}
</code></pre>
</li>
<li><p>修改<code>wepy.config.js</code>加入 runtime 配置（使用<code>async await</code>）</p>
<pre><code class="lang-js">babel: {
    &quot;presets&quot;: [
        &quot;env&quot;
    ],
    &quot;plugins&quot;: [
        &quot;transform-export-extensions&quot;,
        &quot;syntax-export-extensions&quot;
    ]
}
</code></pre>
</li>
</ul>
</li>
<li><p>wepy 异步修改 data 里面的数据需要在赋值之后添加<code>this.$apply()</code>才能赋值成功</p>
</li>
</ol>
<h3 id="4-wepy-">4. wepy 事件处理</h3>
<p>​ 简单说说自己的感受，文档里说方法放 methods 里，于是我把请求方法 getData 放在 methods 里。在 onLoad 生命周期里调用时，发现需要用 this.methods.getData 调用（吐槽下，wepy 仿 vue，要把事件处理函数方法哦 methods，结果调用不能直接用 this）。然后 getData 里面赋值时 this.$apply()报错，应该是 this 指向问题。（懒得处理，把 getData 丢在 methods 外面一样能用，这样写更像 react，还不用解决 this 指向）</p>
<p>​ 总结下，methods 里面放触发事件，比如页面的点击事件。methods 外面放生命周期的处理事件，比如请求</p>
<p>​ wepy 的事件绑定： @代替 bind。类似 vue</p>
<pre><code class="lang-js">@tap=&quot;tapName({{index}}, &#39;wepy&#39;, &#39;otherparams&#39;)&quot;
</code></pre>
<h3 id="5-">5. 页面跳转说明</h3>
<p>使用 navigator 组件的时候，需要指定 open-type 来实现不同的跳转方式，当需要跳转到 tabBar 页面的时候，open-type 需要设置为 switchTab 才能实现页面跳转</p>
<p>编程式导航</p>
<pre><code class="lang-js">wx.navigateTo({
  url: &quot;/pages/goods_detail&quot;
});
</code></pre>
<ol>
<li>小程序页面跳转说明</li>
</ol>
<p>navigate 跳转：保留当前页面，跳转到应用的某个页面，小程序中页面栈最多十层</p>
<p>tabBar 跳转：跳转 tabBar 页面，并关闭其他所有非 tabBar 页面</p>
<p>navigate 返回跳转：关闭当前页面，返回上一页面</p>
<h3 id="6-wepy-">6. wepy 中数据双向绑定原理</h3>
<p>赃值检查</p>
<h3 id="7-">7. 计算属性</h3>
<p>等同 vue 的计算属性</p>
<pre><code class="lang-js">computed = {
  toggleCheckAll() {
    return this.cartList.every(item =&gt; item.isChecked);
  }
};
</code></pre>
<h3 id="8-watcher-">8. watcher 监听器</h3>
<pre><code class="lang-js">watch = {
  cartList(newValue) {
    //方法名与监听数据同名
  }
};
</code></pre>
<h3 id="9-interceptor-">9. interceptor 拦截器</h3>
<p>在 app.wpy 文件中添加 interceptor 拦截器</p>
<p>见文档</p>
<pre><code class="lang-js">constructor(){
    super()
    this.intercept(&#39;request&#39;,{
        //发送请求时的回调函数
        config(p){
            // 请求头添加内容
            p.header.authorization=wepy.getStorageSync(&#39;token&#39;)
            return p
        }
        //请求成功后的回调函数
        success(p){
            return p
        }
        //请求失败后的回调函数
        fail(p){
            return p
           }
    })
}
</code></pre>
<h3 id="10-">10. 封装组件</h3>
<p>组件文件中声明的组件实例继承自 wepy.component 类</p>
<pre><code class="lang-js">export default class Com extends wepy.component {
  components = {};
  data = {};
  methods = {};
  events = {};
}
</code></pre>
<h3 id="11-slot-">11. slot 插槽</h3>
<p>wepy 中的 slot 插槽：父组件更灵活对子组件进行内容分发</p>
<pre><code class="lang-html">// 父组件
&lt;view&gt;
  &lt;Child&gt;
    &lt;view&gt;slot插槽&lt;/view&gt;
  &lt;/Child&gt;
&lt;/view&gt;
// 子组件
&lt;view&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/view&gt;
</code></pre>
<h3 id="12-props-wepy-">12. props 传值(wepy 父子通信)</h3>
<ol>
<li><p>静态传值</p>
<p>子组件通过 props 接收父组件传递来的数据</p>
</li>
<li><p>动态传值</p>
<p>父子组件数据完全独立互不干扰。但是可以在父组件中通过.sync 修饰符来实现父传子</p>
<p>子组件通过 props 数据属性的<code>twoWay:true</code>来达到子传父</p>
<p>两个同时使用时，达到父子双向数据绑定的效果</p>
</li>
</ol>
<h2 id="15-wxparse-">15. wxParse 插件</h2>
<p><a href="https://github.com/icindy/wxParse">wxParse 文档</a></p>
<p>他可以将 html，markdown 转成 wxml</p>
<ul>
<li><p>1 下载项目</p>
<pre><code class="lang-js"> git clone https://github.com/icindy/wxParse.git
</code></pre>
</li>
<li><p>2 拷贝 wxParse 目录到项目中</p>
</li>
<li><p>3 在页面中导入 js/css</p>
<pre><code class="lang-html">// 在 goods_detail 页面中导入：

&lt;style&gt;
  // 导入 wxparse 的样式
  @import &quot;../vendor/wxParse/wxParse.wxss&quot;;
&lt;/style&gt;

&lt;script&gt;
  // 导入 wxparse
  import WxParse from &quot;../wxParse/wxParse&quot;;
&lt;/script&gt;
</code></pre>
</li>
<li><p>4 调用 xwParse 解析 HTML</p>
<pre><code class="lang-js">var article = &quot;&lt;div&gt;我是HTML代码&lt;/div&gt;&quot;;
/**
 * WxParse.wxParse(bindName , type, data, target,imagePadding)
 * 1.bindName绑定的数据名(必填)
 * 2.type可以为html或者md(必填)
 * 3.data为传入的具体数据(必填)
 * 4.target为Page对象,一般为this(必填)
 * 5.imagePadding为当图片自适应是左右的单一padding(默认为0,可选)
 */
var that = this;
WxParse.wxParse(&quot;article&quot;, &quot;html&quot;, article, that, 5);
</code></pre>
</li>
<li><p>5 在展示页面内容的位置添加以下内容</p>
<pre><code class="lang-html">&lt;!-- 引入模板 --&gt;
&lt;import src=&quot;你的路径/wxParse/wxParse.wxml&quot; /&gt;
&lt;!-- 这里data中article为bindName --&gt;
&lt;template is=&quot;wxParse&quot; data=&quot;{{wxParseData:article.nodes}}&quot; /&gt;
</code></pre>
</li>
</ul>
<h2 id="16-template-import-">16. 原生 template 与 import 组件</h2>
<ol>
<li>template</li>
</ol>
<p>wxml 可以定义代码片段，然后在不同的地方调用</p>
<ul>
<li><p>定义模板</p>
<pre><code class="lang-html">&lt;template name=&quot;button&quot;&gt;
  &lt;button&gt;{{btnText}}&lt;/button&gt;
&lt;/template&gt;
</code></pre>
</li>
<li><p>使用模板</p>
<pre><code class="lang-html">&lt;template is=&quot;button&quot; data=&quot;{{...item}}&quot;&gt;&lt;/template&gt;
</code></pre>
</li>
<li><p>import</p>
</li>
</ul>
<p>import 可以在文件任意地方引用自定义的 template</p>
<pre><code class="lang-html">// item.wxml 为自定义的template
&lt;import src=&quot;item.wxml&quot; /&gt;
&lt;template is=&quot;item&quot; data=&quot;{{text:&#39;123&#39;}}&quot; /&gt;
</code></pre>
<h2 id="17-">17. 小程序授权</h2>
<p>主要是授权被拒绝后，引导用户打开设置的过程</p>
<p>注：<code>wx.openSetting</code>必须由 tap 事件触发</p>
<pre><code class="lang-js">wx.getSetting({
  success(res) {
    // 获取用户授权情况
    // res.authSetting是个对象，里面包含多个授权情况
    console.log(res.authSetting);
    if (res.authSetting[&quot;scope.address&quot;] === false) {
      // 拒绝授权的情况
      wx.showModal({
        title: &quot;提示&quot;,
        content: &quot;请点击确定前往设置页面授权&quot;,
        success(res) {
          if (res.confirm) {
            // 用户点击确定
            wx.openSetting({
              success(res) {
                if (res.authSetting[&quot;scope.address&quot;] === true) {
                  // 开启设置后的处理
                }
              }
            });
          }
        }
      });
    } else {
      // 第一次授权或者用户已经授权后的处理
    }
  }
});
</code></pre>
<h2 id="18-">18. 微信授权登录</h2>
<ol>
<li><p>登录流程</p>
</li>
<li><p>前端通过<code>wx.login()</code>获取 code</p>
</li>
<li>前端通过<code>wx.getUserInfo()</code>获取用户信息（微信更新后，获取用户信息必须通过用户点击，详情见文档）</li>
<li>前端通过<code>wx.request()</code>将 code，用户信息发送给后端</li>
<li>后端将 appid、appsecret、code 调用微信接口服务，获取 openid 和 session_key</li>
<li>后端将 openid 和 session_key 生成自定义登录态 token，实现状态保持</li>
<li>将 token 返回前端</li>
<li><p>前端需要登录验证的接口，都需要携带 token</p>
</li>
<li><p>getUserInfo</p>
</li>
<li><p>微信要求用户必须点击来授权登录</p>
</li>
<li><p>获取用户信息的按钮，需要<code>open-type = &quot;getUserInfo&quot;</code></p>
</li>
<li><p>点击事件中通过<code>e.detail</code>获取到用户信息</p>
</li>
<li><p>微信登录配置</p>
</li>
<li><p>从小程序管理后台获取 appId 和 appSecret</p>
</li>
</ol>
<h2 id="19-">19. 微信支付</h2>
<h3 id="1-">1. 支付流程</h3>
<ol>
<li>将收货地址，购买商品信息发送给后端，生成订单 id</li>
<li>根据订单 id 从后端接口获取预支付 wxorder</li>
<li>根据预支付 wxorder 调起微信支付 wx.requestPayment()，弹出微信支付</li>
<li>支付成功后查询支付结果</li>
</ol>
<h3 id="2-">2. 商户接入支付</h3>
<p>微信支付商户平台注册，获取商户 id 及支付 key</p>
<h2 id="20-">20. ...对象扩展运算符不支持时</h2>
<p>...对象扩展运算符不是 ECMAScript 的标准语法</p>
<p>安装 babel-preset-stage-2</p>
<h1 id="echarts">echarts</h1>
<h2 id="1-echarts-vue-">1. echarts 在 vue 项目中的使用</h2>
<h3 id="1-">1. 安装</h3>
<pre><code class="lang-javascript">npm install echarts -S
</code></pre>
<h3 id="2-echarts">2. 引入 echarts</h3>
<pre><code class="lang-javascript">// 在main.js文件中引入echarts并把它注入到vue的原型链上，这样在各个组件上都能使用
import * as echarts from &quot;echarts&quot;;
Vue.prototype.$echarts = echarts;
</code></pre>
<h3 id="3-echarts-">3. echarts 组件</h3>
<pre><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;echarts&quot;&gt;
    &lt;div ref=&quot;echartsRef&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      chartDom: &quot;&quot;,
      option: &quot;&quot;
    };
  },
  props: {
    data: {
      type: Object,
      default: () =&gt; {}
    }
  },
  watch: {
    // 监听数据变化改变图表，而不是重新渲染echarts这样节约内存
    data: {
      handler() {
        this.chartDom.clear();
        this.setData();
      },
      deep: true
    }
  },
  mounted() {
    this.setChart();
    this.setOptionData();
    window.addEventListener(&quot;resize&quot;, this.resizeFn);
  },
  beforeDestroy() {
    // 摧毁的处理需要实际开发验证
    if (this.chartDom) {
      this.chartDom.clear();
    }
    window.removeEventListener(&quot;resize&quot;, this.resizeFn);
  },
  methods: {
    // 初始化echarts
    setChart() {
      this.chartDom = this.$echarts.init(this.$refs.echartsRef);
      this.chartDom.clear();
    },
    // 配置默认option，不包含数据
    setOptionData() {
      this.option = {
        legend: {},
        tooltip: {
          show: true
        },
        grid: {
          show: true
        },
        xAxis: {
          show: true,
          type: &quot;category&quot;,
          axisTick: {
            alignWithLabel: true
          }
        },
        yAxis: {
          position: &quot;left&quot;
        }
      };
      this.chartDom.setOption(this.option);
    },
    // 配置数据，对异常数据处理为显示默认,x轴保持与之前一致
    setData() {
      if (this.data &amp;&amp; this.data.yAxis &amp;&amp; this.data.yAxis.length &gt; 0) {
        const { xAxis, yAxis } = this.data;
        this.option.xAxis.data = xAxis;
        let seriesArr = yAxis.map(i =&gt; {
          return {
            name: i.name,
            type: &quot;bar&quot;,
            stack: i.name,
            data: i.data
          };
        });
        this.option.series = [...seriesArr];
      } else {
        this.option.series = [];
      }
      this.chartDom.setOption(this.option);
    },
    resizeFn() {
      this.chartDom.resize();
    }
  }
};
&lt;/script&gt;
&lt;style lang=&quot;less&quot; scoped&gt;
.echarts {
  width: 100%;
  height: 100%;
  // &gt;div表示echartsDom 必须设置宽高，这里是继承父元素的宽高。所以引入该组件的盒子必须给定宽高
  &gt; div {
    width: 100%;
    height: 100%;
  }
}
&lt;/style&gt;
</code></pre>
<h2 id="2-echarts-">2. echarts 的配置项</h2>
<h3 id="1-">1. 官方文档</h3>
<p><a href="https://echarts.apache.org/zh/option.html#title">官方文档</a></p>
<h3 id="2-series-">2. series（最重要的，给数据，决定图表类型）</h3>
<ol>
<li>折线图</li>
</ol>
<pre><code class="lang-javascript">const options =
{
    series:[
        {
            // 图表类型，还有bar，pie，map。map会在后面说明，其他的看文档
            type:line,
            // 在tooltip的显示（需要自定义悬浮框内容，回调函数里可以拿到name值），legend的图例筛选
            name:&#39;邮件营销&#39;,
            // 设置了相同的stack值，数据会堆叠（适合给堆叠图配置）
            stack:&#39;总量&#39;,
            /**
                设置拐点（仅在折线图中）以及标注图例的形状（在legend中会介绍它与icon的区别）
                &#39;circle&#39;（圆形）, &#39;rect&#39;（矩形）, &#39;roundRect&#39;（圆角矩形）, &#39;triangle&#39;（三角形）,
                &#39;diamond&#39;（菱形）, &#39;pin&#39;（定位）, &#39;arrow&#39;（箭头）, &#39;none&#39;。还支持url以及dataURI
            */
            symbol:&#39;emptyCircle&#39;
            // 设置拐点的样式（颜色，透明度，边框颜色，边框宽度）
            itemStyle:{},
            // 设置线条的样式（颜色，透明度，线条宽度，线条类型）
            lineStyle:{
                // 线条类型，实线，虚线，点线;solid,dashed,dotted
                type:&#39;solid&#39;;
            },
            // 设置区域的样式
            areaStyle:{},
            // 设置拐点上面文本
            label:{
                // 显示隐藏
                show:true,
                /**
                    文本位置:支持：top / left / right / bottom / inside / insideLeft /
                    insideRight / insideTop / insideBottom / insideTopLeft /
                    insideBottomLeft / insideTopRight / insideBottomRight
                    也可以用一个数组表示相对的百分比或者绝对像素值表示标签相对于图形包围盒左上角的位置
                    [&quot;50%&quot;,&quot;50%&quot;],[10,10]
                */
                position:&#39;top&#39;,
                /**
                    自定义文本 支持字符串模板，以及回调函数
                    tooltip回调中有异步，这里没有，如果需要使用参考文档
                    将会在tooltip中着重介绍
                */
                formatter:&#39;&#39;,
                /**
                    自定义文本样式，将会在tooltip中着重介绍
                */
                rich:&#39;&#39;,
                // 文字水平对齐方式
                align:&#39;center&#39;,
                // 文字垂直对齐方式
                verticalAlign:&#39;middle&#39;

            },
            // 特定的tooltip，同后面介绍的tooltip
            tooltip:{}
            /**
                具体数据，data内容一一对应xAxis.data的值，详见文档。还可以设置单个数据的特殊样式
            */
            data:[]
            // 其他配置见文档
        }
    ]
}
</code></pre>
<ol>
<li>柱状图</li>
</ol>
<pre><code class="lang-javascript">// 大部分配置参照折线图，以下介绍特殊的属性
const options = {
  series: [
    {
      // 柱条宽度
      barWidth: &quot;10%&quot;,
      // 柱条间隙，为-100%时重叠
      barGap: &quot;30%&quot;
    }
  ]
};
</code></pre>
<ol>
<li>饼图</li>
</ol>
<pre><code class="lang-javascript">const options = {
  series: [
    {
      // 起始角度
      startAngle: 90,
      // 饼图的内、外半径
      radius: [&quot;20%&quot;, &quot;50%&quot;],
      // 圆心相对容器的位置
      center: [&quot;50%&quot;, &quot;50%&quot;]
    }
  ]
};
</code></pre>
<h3 id="3-legend-">3. legend（图例组件）</h3>
<pre><code class="lang-javascript">const options = {
  legend: {
    // 图例的显示必须要有data，并且series的name属性有对应的
    data: [&quot;广告&quot;, &quot;视频&quot;, &quot;微博&quot;],
    // 图例的类型 plain普通图例 scroll可滚动翻页
    type: &quot;plain&quot;,
    // 图例列表的布局朝向 horizontal水平 vertical垂直
    orient: &quot;horizontal&quot;,
    // 图例之间的间隙（图例与图例）
    itemGap: 10,
    // 图例图行的宽高
    itemWidth: 10,
    itemHeight: 10,
    /**
            格式化图例文本
            字符串模板，支持回调函数function(name){}
        */
    formatter: &quot;Legeng {name}&quot;,
    // 图例选择模式，控制是否可以通过点击图例来显示隐藏对应数据
    selectedMode: false,
    // 图例公用文本样式（颜色，字体，字体大小，行高等）
    textStyle: {
      // 文字块的内边距（这样可以设置文字与图案的间隙）
      padding: [3, 4, 5, 6]
    },
    // 图例项的icon 同series.symbol。图例的样式由icon决定，没有设置icon的时候，由symbol决定
    icon: &quot;circle&quot;
  }
};
</code></pre>
<h3 id="4-grid-">4. grid（直角坐标系内绘图网格）</h3>
<pre><code class="lang-javascript">const options = {
  grid: {
    // 是否显示网格
    show: true,
    // 坐标系在容器中的位置
    left: &quot;50%&quot;,
    top: &quot;50%&quot;,
    // right:&#39;50%&#39;,
    // bottom:&#39;50%&#39;,
    // grid区域是否包含坐标轴的刻度标签 为true可以防止刻度标签过长溢出容器
    containLabel: true
  }
};
</code></pre>
<h3 id="5-xaxis-x-">5. xAxis（X 轴设置）</h3>
<pre><code class="lang-javascript">const options = {
  xAxis: {
    show: true,
    // x轴的位置 top，bottom（没有刻度线）
    position: &quot;top&quot;,
    // 坐标轴类型 value数值轴，category类目轴，time时间轴，log对数轴
    type: &quot;time&quot;,
    // 坐标轴名称 会在坐标轴显示名称
    name: &quot;日期&quot;,
    // 坐标轴名称显示位置 start middle或者center end
    nameLocation: &quot;end&quot;,
    // 坐标轴名称的文字样式
    nameTextStyle: {},
    // 坐标轴名称与轴线的距离
    nameGap: 15,
    // 坐标轴名字旋转
    nameRotate: 90,
    // 坐标轴两边留白 类目轴true，false配置，非类目轴数组
    boundaryGap: [&quot;20%&quot;, &quot;20%&quot;],
    // 坐标轴最大，最小值（详见文档）
    min: -100,
    max: 100,
    // 坐标轴轴线相关
    axisLine: {},
    // 坐标轴刻度相关
    axisTick: {
      // 当type为category时，并且boundaryGap为true，这个属性可以让刻度线与标签对齐
      alignWithLabel: true
    },
    // 坐标轴次刻度线相关（仅在type非category有效）
    minorTick: {},
    // 坐标轴刻度标签相关
    axisLabel: {},
    // 分隔线
    splitLine: {},
    // 类目数据
    data: [],
    // 坐标轴指示器配置项
    axisPointer: {
      show: true,
      // 指示器类型 line shadow none
      type: &quot;line&quot;,
      // 坐标轴指示器的文本标签（用的不多，见文档）
      label: {}
    }
  }
};
</code></pre>
<h3 id="6-yaxis-y-">6. yAxis（Y 轴设置）</h3>
<pre><code class="lang-javascript">const options = {
  yAxis: {
    // y轴位置，只有left，right
    position: &quot;left&quot;
  }
};
</code></pre>
<h3 id="7-axispointer-">7. axisPointer（全局坐标轴指示器）</h3>
<p>等同于 x 轴 y 轴的 axisPointer</p>
<p>x 轴、y 轴&gt;全局&gt;tooltip</p>
<h3 id="8-tooltip-">8.tooltip（提示框组件）</h3>
<p>提示框组件可以设置在多种地方</p>
<ul>
<li>全局：tooltip</li>
<li>坐标系：grid.tooltip</li>
<li>系列：series.tooltip</li>
<li>系列中每个数据：series.data.tooltip</li>
</ul>
<pre><code class="lang-javascript">const options = {
    tooltip:{
        // 展示隐藏
        show:true,
        // 触发方式 item：散点或者饼图等无类目，axis，坐标轴触发，柱状图或折线图等类目，none
        trigger:&#39;axis&#39;,
        // 坐标轴指示器，等同于x轴y轴的axisPointer，以及全局axisPointer
        axisPointer:{}
        // 当只需要触发hover效果或者显示axisPointer而不需要显示内容，配置为false
        showContent:false,
        // 提示框悬浮的位置，Array，function（详见文档）
        position:[&#39;50%&#39;,&#39;50%&#39;],
        // 提示框内容是否限制在图表区域内（防止提示框显示在图表外遮挡其他内容）
        confine:true,
        // 内容格式器（下文着重介绍）
        formatter:&#39;{a}&#39;
    }
}
</code></pre>
<h3 id="9-formatter-">9. formatter（格式器）</h3>
<p>着重介绍 tooltip 里的使用，其他地方使用方法基本一致</p>
<ol>
<li>字符串模板</li>
</ol>
<pre><code class="lang-javascript">// 示例
formatter: &quot;{a}:{b}&lt;br /&gt;{c}({d})&quot;;
</code></pre>
<ul>
<li>折线图、柱状图：<code>{a}</code>（系列名称），<code>{b}</code>（类目值），<code>{c}</code>（数值）</li>
<li>散点图（气泡）图 : <code>{a}</code>（系列名称），<code>{b}</code>（数据名称），<code>{c}</code>（数值数组）</li>
<li>地图 : <code>{a}</code>（系列名称），<code>{b}</code>（区域名称），<code>{c}</code>（合并数值）</li>
<li>饼图、仪表盘、漏斗图: <code>{a}</code>（系列名称），<code>{b}</code>（数据项名称），<code>{c}</code>（数值）, <code>{d}</code>（百分比）</li>
</ul>
<p>更多其它图表模板变量的含义可以见相应的图表的 label.formatter 配置项。</p>
<ol>
<li>回调函数</li>
</ol>
<pre><code class="lang-javascript">// 示例
formatter: (params, ticket, callback) =&gt; {};
</code></pre>
<p><code>params</code>：可以拿到需要的所有数据</p>
<p><code>ticket</code>配合<code>callback</code>使用，当数据时异步获取时，通过这两个参数更新提示框内容。</p>
<p>因为 tooltip 的触发很频繁，所以异步请求获取数据时可以做一些数据缓存的操作，优先从缓存中获取数据，获取不到时再去发送请求</p>
<pre><code class="lang-javascript">// 示例
formatter:(params,ticket,callback)=&gt;{
    // 获取id并根据id发送异步请求
    const{id} = params.data
    // 省略缓存存取的过程，直接发送请求
    getData(id).then(res=&gt;{
        setInterval(()=&gt;{
            // toHtml是拿数据转换成html的方法
            callback(ticket,toHtml(res))
        },0)
    })
    // 数据等待时显示文案
    return &#39;数据加载中。。。&#39;
}
toHtml(res)=&gt;{
    const {name,value} = res
    // 返回值带有html，暂时没有发现css怎么修改这些样式，所以使用行内样式，格式更美观使用&lt;table&gt;标签
    return `&lt;div style=&#39;color:#4050FF&#39;&gt;${name}:${value}&lt;/div&gt;`
}
</code></pre>
<h3 id="10-echarts-">10. echarts 地图渲染</h3>
<ol>
<li>注入地图</li>
</ol>
<p><a href="http://datav.aliyun.com/tools/atlas/#&amp;lat=31.769817845138945&amp;lng=104.29901249999999&amp;zoom=3">地图 JSON 获取地址</a> 失效请自行百度找寻</p>
<pre><code class="lang-javascript">// name：为注入地图名称自定义，geoJSON：地图的JSON文件
this.$echarts.registerMap(name, geoJSON);
</code></pre>
<ol>
<li>配置 option</li>
</ol>
<pre><code class="lang-javascript">const options = {
  // 地理坐标系组件
  geo: {
    show: true,
    // 地图名称即注入地图时自定义的名称
    map: &quot;china&quot;,
    // 当前视角的中心点，经纬度，具体情况具体数据
    center: [115.97, 29.71],
    // 鼠标缩放，平移滑动开启关闭
    roam: false,
    // 地图长宽比
    aspectScale: 1,
    // 当前视角缩放比
    zoom: 1,
    // 缩放比限制
    scaleLimit: {
      min: 0.9,
      max: 1.1
    },
    // 图形上面的标签设置
    label: {},
    // 地图区域多边形 图形样式
    itemStyle: {},
    // 高亮下多边形 图形样式
    emphasis: {}
  },
  // 为了显示区域划分
  visualMap: {
    show: false, // 设为false不会显示控件，但数据还是会显示
    seriesIndex: [1], // 绑定系列，对应type为map的series
    min: 0,
    max: 30,
    text: [&quot;high&quot;, &quot;low&quot;],
    // 控件文字颜色
    textStyle: {
      color: &quot;#fff&quot;
    },
    inRange: {
      // 区域颜色
      color: [&quot;#52A7FF&quot;, &quot;#3686F1&quot;, &quot;#0441C4&quot;]
    }
  },
  tooltip: {
    trigger: &quot;item&quot;,
    confine: true
  },
  legend: {},
  series: [
    // 地图上坐标点的渲染
    {
      name: &quot;坐标点&quot;,
      // scatter散点图，effectScatter带涟漪特效的散点图
      type: &quot;scatter&quot;,
      // 该系列使用的坐标系 cartesian2d 二维的直角坐标系，polar极坐标系，geo地理坐标系（地图使用）
      coordinateSystem: &quot;geo&quot;,
      // 单个图表有多个地理坐标系时使用
      geoIndex: 0,
      // 标记的图形
      symbol: &quot;circle&quot;,
      // 标记图形尺寸
      symbolSize: 10,
      tooltip: {
        // 设置tooltip浮层css样式 仅在serier.tooltip.trigger为item时有效
        extraCssText: &quot;box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);&quot;,
        // 这里用来展示
        formatter: &quot;{a}&quot;
      },
      // 图形样式
      itemStyle: {},
      // 特效类型 （仅有ripple一个特效）（仅在type为effectScatter设置）
      effectType: &quot;ripple&quot;,
      // 何时展示特效 render渲染时 emphasis高亮时（仅在type为effectScatter设置）
      showEffectOn: &quot;render&quot;,
      // 涟漪特效相关配置（仅在type为effectScatter设置）
      rippleEffect: {},
      // 数据
      data: []
    },
    // 地图渲染（地区颜色区分算是背景吧）
    {
      type: &quot;map&quot;,
      // 自定义扩展图表类型
      mapType: &quot;china&quot;,
      center: [115.97, 29.71],
      // 作为背景不需要显示图例颜色标识
      showLegendSymbol: false,
      itemStyle: {},
      // 一些地图的大小保持与geo一致这样可以覆盖geo生成的地图
      // 可能不是后端返回的，需要前端自己造
      data: []
    }
  ]
};
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>